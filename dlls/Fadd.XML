<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fadd</name>
    </assembly>
    <members>
        <member name="T:Fadd.Validation.ValidateBetweenAttribute">
            <summary>
            Checks if a primitive type is between min and max.
            </summary>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>Between</term>
                    <description>'{0}' must be between {1} and {2}.</description>
                </item>
                <item>
                    <term>BetweenString</term>
                    <description>'{0}' may only have {1} up to {2} letters.</description>
                </item>
              <item>
            	  <term>BetweenStringLength</term>
                     <description>'{0}' must be {1} letters long.</description>
                 </item>
            </list>
            </para>
        </member>
        <member name="T:Fadd.Validation.ValidateAttribute">
            <summary>
            Base class for all Fadd validation attributes.
            </summary>
            <remarks>
            <para>
            Each validation class should document what their language entries should say, and their names.
            This should be done in the remarks section using a table list, example:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>ValidateLetters</term>
                    <description>'{0}' may only contain letters.</description>
                </item>
                <item>
                    <term>ValidateLettersExtra</term>
                    <description>'{0}' may only contain letters and one of the following characters: {1}</description>
                </item>
            </list>
            It's recommended that the item names (or terms in the table above) equals the validation class name.
            i.e. ValidateEmailAttributes adds a language item called "Email".
            </para>
            </remarks>
        </member>
        <member name="M:Fadd.Validation.ValidateAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ValidateAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="M:Fadd.Validation.ValidateAttribute.IsEmpty(System.Object)">
            <summary>
            Check's whether a value is empty or not.
            </summary>
            <param name="value">value to check.</param>
            <returns>true if the value is empty.</returns>
        </member>
        <member name="M:Fadd.Validation.ValidateAttribute.IsEmpty(System.Object,System.Object)">
            <summary>
            Check's whether a value is empty or not.
            </summary>
            <param name="value">value to check.</param>
            <param name="emptyValue">value is considered to be not specified if the value matches this parameter</param>
            <returns>true if the value is empty.</returns>
        </member>
        <member name="M:Fadd.Validation.ValidateBetweenAttribute.#ctor(System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateAttribute"/> class.
            </summary>
            <param name="min">Value must be equal to this or larger.</param>
            <param name="max">Value must be equal or less than this.</param>
            <exception cref="T:System.ArgumentException">Thrown if the max value is more than the min value</exception>
        </member>
        <member name="M:Fadd.Validation.ValidateBetweenAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">Thrown if an unsupported object value is supplied</exception>
        </member>
        <member name="M:Fadd.Validation.ValidateBetweenAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateBetweenAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="P:Fadd.Validation.ValidateBetweenAttribute.Min">
            <summary>
            Min value
            </summary>
        </member>
        <member name="P:Fadd.Validation.ValidateBetweenAttribute.Max">
            <summary>
            Max value
            </summary>
        </member>
        <member name="T:Fadd.Commands.Tests.TestObject">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Commands.Tests.ITestObject">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.ITestObject.TestIt(System.String,System.Int32)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">My arg.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.Tests.ITestObject.TestIt(System.String,System.Boolean)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">My arg.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.Tests.ITestObject.DoThis">
            <summary>
            Does the this.
            </summary>
        </member>
        <member name="P:Fadd.Commands.Tests.ITestObject.Id">
            <summary>
            Modify the id of the testobject
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.TestObject.TestIt(System.String,System.Int32)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">My arg.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.Tests.TestObject.TestIt(System.String,System.Boolean)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">My arg.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.Tests.TestObject.DoThis">
            <summary>
            Does the this.
            </summary>
        </member>
        <member name="P:Fadd.Commands.Tests.TestObject.Id">
            <summary>
            Modify the id of the testobject
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.CommandChannel">
            <summary>
            This class creates a command channel which can be used to send a command to a remote end point.
            </summary>
        </member>
        <member name="F:Fadd.Commands.Net.CommandChannel.DefaultPort">
            <summary>
            Try to use this port if it's not occupied.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.#ctor(Fadd.Commands.ICommandDispatcher)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.CommandChannel"/> class.
            </summary>
            <param name="dispatcher">Dispatcher used to invoke commands comming through the channel.</param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.#ctor(Fadd.Commands.ICommandDispatcher,System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.CommandChannel"/> class.
            </summary>
            <param name="dispatcher">Dispatcher used to invoke commands comming through the channel.</param>
            <param name="socket">Socket used to transport commands.</param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.#ctor(Fadd.Commands.ICommandDispatcher,Fadd.Commands.Net.BinaryChannel)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.CommandChannel"/> class.
            </summary>
            <param name="dispatcher">Dispatcher used to invoke commands comming through the channel.</param>
            <param name="channel">Channel used to tranport commands.</param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Fadd.Commands.Net.CommandChannel"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.ProcessUnhandledCommands(System.Boolean)">
            <summary>
            Send unhandled commands through the tunnel.
            </summary>
            <remarks>
            Off by defualt.
            </remarks>
            <param name="value"></param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.ProcessRemoteCommands(System.Boolean)">
            <summary>
            Handle commands tagged with the <see cref="T:Fadd.Commands.IRemote"/> interface.
            </summary>
            <param name="value"></param>
            <remarks>Off by default.</remarks>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.Open(System.Net.IPEndPoint)">
            <summary>
            Connect to other side.
            </summary>
            <param name="endPoint"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.Close">
            <summary>
            Close command tunnel
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.CommandChannel.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="E:Fadd.Commands.Net.CommandChannel.Disconnected">
            <summary>
            Invoked when client disconnects
            </summary>
        </member>
        <member name="P:Fadd.Commands.Net.CommandChannel.AutoReconnect">
            <summary>
            True if socket should auto reconnect connection is closed due to any network error.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.AndToken">
            <summary>
            Parse 'AND'
            </summary>
        </member>
        <member name="T:Fadd.Parser.ParseTreeToken">
            <summary>
            Tokens are used to parse a specific part of the text.
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.ParseChildren(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Should be called in <see cref="M:Fadd.Parser.ParseTreeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)"/> to let the Token parse all children.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if a child have been matched and parsed.</returns>
            <remarks>Are called from <see cref="M:Fadd.Parser.ParseTreeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)"/>.</remarks>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.ParseOneChild(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Should be called in <see cref="M:Fadd.Parser.ParseTreeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)"/> to let the Token parse all children.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if a child have been matched and parsed.</returns>
            <remarks>Are called from <see cref="M:Fadd.Parser.ParseTreeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)"/>.</remarks>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.MatchChildren(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree,System.Type)">
            <summary>
            Used to check if another child got a match
            </summary>
            <param name="tokenizer"><see cref="T:Fadd.Parser.Tokenizer"/> used to read data.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> being built.</param>
            <param name="exceptMe"><see cref="T:Fadd.Parser.ParseTreeToken"/> that should not be included in the check.</param>
            <returns>true if a child matches the current position in the <see cref="T:Fadd.Parser.Tokenizer"/></returns>
        </member>
        <member name="M:Fadd.Parser.ParseTreeToken.Add(Fadd.Parser.ParseTreeToken)">
            <summary>
            Add a  possible child token.
            </summary>
            <param name="parseTreeToken">The token.</param>
        </member>
        <member name="P:Fadd.Parser.ParseTreeToken.Parent">
            <summary>
            Get parent token
            </summary>
        </member>
        <member name="P:Fadd.Parser.ParseTreeToken.FinalChild">
            <summary>
            This token is the final child in the current leaf, parse no more children
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.AndToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.AndToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Parser">
            <summary>
            Used to parse SQL conditions
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.Parser.WhiteSpaces">
            <summary>
            Chars interpreted as white spaces: NewLine,LineFeed,Tab,Space
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Parser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Parser"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Parser.Setup">
            <summary>
            Setup all tokens
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Parser.Parse(System.String)">
            <summary>
            Parse the tree
            </summary>
            <param name="text">Text to parse.</param>
            <returns>a parsed tree</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StarToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StarToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.NotEqual">
            <summary>
            Not equal condition
            </summary>
        </member>
        <member name="T:Fadd.Parser.Token">
            <summary>
            Base class for all objects that are used to build a tree.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Token.Add(Fadd.Parser.Token)">
            <summary>
            Adds the specified child.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:Fadd.Parser.Token.GetEnumerator">
            <summary>
                                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Fadd.Parser.Token.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Fadd.Parser.Token.ToString(System.Boolean)">
            <summary>
            String representation of the token
            </summary>
            <param name="includeChildren">Also include all children in the output</param>
            <returns>Returns a human friendly string</returns>
        </member>
        <member name="P:Fadd.Parser.Token.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="P:Fadd.Parser.Token.Parent">
            <summary>
            Gets or sets the parent.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Fadd.Parser.Token.LastChild">
            <summary>
            Last added child in the current node.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Token.Children">
            <summary>
            Gets the items.
            </summary>
            <value>The items.</value>
        </member>
        <member name="P:Fadd.Parser.Token.Item(System.Int32)">
            <summary>
            Get one of the children
            </summary>
            <param name="index">zero-based index.</param>
            <returns><see cref="T:Fadd.Parser.Token"/></returns>
        </member>
        <member name="P:Fadd.Parser.Token.Depth">
            <summary>
            Depth in parse tree.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Token.Count">
            <summary>
            Number of children.
            </summary>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.IConditional">
            <summary>
            Used to identify conditions (used by Property to see it the text is a property or something else)
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.NotEqual.ToString">
            <summary>
            Condition string
            </summary>
            <returns>" != "</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.NotEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.LessOrEqual">
            <summary>
             <![CDATA[
            <=
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.LessOrEqual.ToString">
            <summary>
            Conditional representation.
            </summary>
            <returns><![CDATA[" <= "]]></returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.LessOrEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.Equal">
            <summary>
            = or ==
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.Equal.ToString">
            <summary>
            Equal condition as string
            </summary>
            <returns>" == "</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.Equal.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.Context">
            <summary>
            We are getting into a sub context (nested conditions)
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.Context.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.OrToken">
            <summary>
            Parse a OR token
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.OrToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.OrToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Parser">
            <summary>
            Used to parse SQL conditions
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.Parser.WhiteSpaces">
            <summary>
            New Line, Line Feed, Tab and Space.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Parser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.Evaluator.Parser"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Parser.Setup">
            <summary>
            Setup all tokens
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Parser.Parse(System.String)">
            <summary>
            Parse the tree
            </summary>
            <param name="text">Text to parse.</param>
            <returns>a parsed tree</returns>
        </member>
        <member name="T:Fadd.Plugins.EvidenceRequestedEventArgs">
            <summary>
            Arguments for <see cref="T:Fadd.Plugins.EvidenceRequestedHandler"/>
            </summary>
        </member>
        <member name="M:Fadd.Plugins.EvidenceRequestedEventArgs.#ctor(Fadd.Plugins.PluginTypeInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.EvidenceRequestedEventArgs"/> class.
            </summary>
            <param name="typeInfo">Plugin assembly information.</param>
        </member>
        <member name="P:Fadd.Plugins.EvidenceRequestedEventArgs.Evidence">
            <summary>
            Evidence that the plugin should be loaded with.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.EvidenceRequestedEventArgs.TypeInformation">
            <summary>
            Plugin assembly information
            </summary>
        </member>
        <member name="T:Fadd.Plugins.EvidenceRequestedHandler">
            <summary>
             Called when an assembly is about to be loaded and we need the evidence for it.
             Specify the evidence by using <see cref="P:Fadd.Plugins.EvidenceRequestedEventArgs.Evidence"/>
            </summary>
            <param name="source">PluginManager</param>
            <param name="args">Assembly information</param>
        </member>
        <member name="T:Fadd.Globalization.EmptyLanguageNode">
            <summary>
            This node is returned instead of null.
            </summary>
        </member>
        <member name="T:Fadd.Globalization.LanguageNode">
            <summary>
            Contains language translations used to create multilingual applications
            </summary>
            <remarks>
            The LanguageNode provides a base class for different implementations of a hierachial language structure
            </remarks>
        </member>
        <member name="T:Fadd.Globalization.ILanguageNode">
            <summary>
            Contains language translations used to create multilingual applications
            </summary>
            <remarks>
            The ILanguageNode provides a base class for different implementations of a hierachial language structure
            </remarks>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.GetText(System.Int32,System.String)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.GetText(System.Int32,System.String,System.Boolean)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <param name="checkPaths">check for paths in <paramref name="textName"/>.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.GetChild(System.String)">
            <summary>
            Gets a sub category
            </summary>
            <param name="name">The category name</param>
            <returns><see cref="T:Fadd.Globalization.ILanguageNode"/> if found; otherwise null.</returns>
            <exception cref="T:System.ArgumentNullException">If name is null</exception>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.GetTextCount(System.Int32)">
            <summary>
            Number of translated texts in the specified language.
            </summary>
            <param name="lcid">Language to get text from.</param>
            <returns>Number of text items</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.Contains(System.String)">
            <summary>
            Determine if the node contains a text item with the specified name (for the current lcid)
            </summary>
            <returns>True if the node contains a language element with the specified name for the current language</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.Contains(System.String,System.Int32)">
            <summary>
            Determine if the node contains a text item with the specified name for the specified language
            </summary>
            <returns>True if the node contains a language element with the specified name for the specified language</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.ContainsLanguage(System.Int32)">
            <summary>
            Determine if a category contains a specific language.
            </summary>
            <param name="lcid">Language to get text from.</param>
            <returns>true if the specified language contains the text string; false if not.</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.ContainsChild(System.String)">
            <summary>
            Checks if current language contains a child node with the specified name.
            </summary>
            <param name="name">Name of child node</param>
            <returns>true if found; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageNode.ClearHierarchy">
            <summary>Empties all saved values in the node and its sub nodes</summary>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.ParentNode">
            <summary>
            Gets the parent language node. 
            </summary>
            <remarks>
            null if no parent node exists.
            </remarks>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.RootNode">
            <summary>
            Gets the mother of all nodes.
            </summary>
            <remarks>
            Root node will return itself.
            </remarks>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.Count">
            <summary>
            Gets the number of languages (and not the number of text items).
            </summary>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.Name">
            <summary>
            Gets the name of this node.
            </summary>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.DefaultLCID">
            <summary>
            Gets language to use if the requested language is not found.
            </summary>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.Item(System.String)">
            <summary>
            Gets a localized text string in the current language.
            </summary>
            <param name="textName">Phrase to find, can also contain a path.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["/Users/View/Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="P:Fadd.Globalization.ILanguageNode.Item(System.String,System.Int32)">
            <summary>
            Gets a localized text string in the specified language.
            </summary>
            <param name="textName">Phrase to find, can also contain a path.</param>
            <param name="lcid">Get translation from this language.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="F:Fadd.Globalization.LanguageNode.Empty">
            <summary>
            An empty language node (used instead of null).
            </summary>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Globalization.LanguageNode"/> class.
            </summary>
            <param name="defaultLCID">The default LCID.</param>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.GetText(System.Int32,System.String)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.GetText(System.Int32,System.String,System.Boolean)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <param name="checkPaths">check for paths in <paramref name="textName"/>.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.GetTextCount(System.Int32)">
            <summary>
            Number of translated texts in the specified language
            </summary>
            <param name="lcid"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.Contains(System.String)">
            <summary>
            Determine if the node contains a text item with the specified name (for the current lcid)
            </summary>
            <param name="name"></param>
            <returns>
            True if the node contains a language element with the specified name for the current language
            </returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.Contains(System.String,System.Int32)">
            <summary>
            Determine if the node contains a text item with the specified name for the specified language
            </summary>
            <param name="name"></param>
            <param name="lcid"></param>
            <returns>
            True if the node contains a language element with the specified name for the specified language
            </returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.ContainsLanguage(System.Int32)">
            <summary>
            Determine if a category contains a specific language.
            </summary>
            <param name="lcid"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.ContainsChild(System.String)">
            <summary>
            Checks if current language contains a child node with the specified name.
            </summary>
            <param name="name">Name of child node</param>
            <returns>true if found; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.ClearHierarchy">
            <summary>Empties all saved values in the node and its sub nodes</summary>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.GetChild(System.String)">
            <summary>
            Gets a sub category
            </summary>
            <param name="name">The category name</param>
            <returns>
            	<see cref="T:Fadd.Globalization.ILanguageNode"/> if found; otherwise null.
            </returns>
            <exception cref="T:System.ArgumentNullException">If name is null</exception>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.CheckPaths(System.Int32,System.String)">
            <summary>
            Checks paths that are specified in text names
            </summary>
            <param name="textName">For instance /user/show/firstname</param>
            <param name="lcid">language to check in</param>
            <returns>string if language contains a path, otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.Add(System.String,System.Int32,System.String)">
            <summary>
            Add a localized text string.
            </summary>
            <param name="lcid">locale</param>
            <param name="name">Name identifying the string. Used to fetch the string later on.</param>
            <param name="text">Localized string</param>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.Set(System.String,System.Int32,System.String)">
            <summary>
            Sets a localized text string. If the a string with the specified name exists it will be overwritten.
            </summary>
            <param name="lcid">locale</param>
            <param name="name">Name identifying the string. Used to fetch the string later on.</param>
            <param name="text">Localized string</param>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.AddChild(System.String)">
            <summary>
            Adds a sub category
            </summary>
            <param name="name">Name of the sub category</param>
            <exception cref="T:System.ArgumentException">If a category with the specified name already exists</exception>
            <exception cref="T:System.ArgumentNullException">If name is null</exception>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.EmptyValue(System.String)">
            <summary>
            Value that should be returned if the text is not found.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.LanguageNode.SetDefaultLCID(System.Int32)">
            <summary>
            Set default locale
            </summary>
            <param name="lcid">Locale to set.</param>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.Children">
            <summary>
            All child nodes.
            </summary>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.ParentNode">
            <summary>
            Parent language category
            </summary>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.RootNode">
            <summary>
            Mother of all nodes.
            </summary>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.Item(System.String)">
            <summary>
            Get a localized text string in the current language.
            </summary>
            <param name="textName">Phrase to find.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.Item(System.String,System.Int32)">
            <summary>
            Get a localized text string
            </summary>
            <param name="lcid"></param>
            <param name="textName">Phrase to find.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.Count">
            <summary>
            Number languages
            </summary>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.Name">
            <summary>
            Returns the name of the node
            </summary>
        </member>
        <member name="P:Fadd.Globalization.LanguageNode.DefaultLCID">
            <summary>
            LCID to use if the specified or current LCID is not found.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Globalization.EmptyLanguageNode"/> class.
            </summary>
            <param name="defaultLCID">The default LCID.</param>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.Add(System.String,System.Int32,System.String)">
            <summary>
            Add a localized text string.
            </summary>
            <param name="lcid">locale</param>
            <param name="name">Name identifying the string. Used to fetch the string later on.</param>
            <param name="text">Localized string</param>        
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.Set(System.String,System.Int32,System.String)">
            <summary>
            Sets a localized text string. If the a string with the specified name exists it will be overwritten.
            </summary>
            <param name="name">Name identifying the string. Used to fetch the string later on.</param>
            <param name="lcid">locale</param>
            <param name="text">Localized string</param>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.AddChild(System.String)">
            <summary>
            Adds a sub category
            </summary>
            <param name="name">Name of the sub category</param>
            <exception cref="T:System.ArgumentException">If a category with the specified name already exists</exception>
            <exception cref="T:System.ArgumentNullException">If name is null</exception>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.GetText(System.Int32,System.String)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.GetText(System.Int32,System.String,System.Boolean)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <param name="checkPaths">check for paths in <paramref name="textName"/>.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.GetTextCount(System.Int32)">
            <summary>
            Number of translated texts in the specified language
            </summary>
            <param name="lcid"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.Contains(System.String,System.Int32)">
            <summary>
            Determine if the node contains a text item with the specified name for the specified language
            </summary>
            <param name="name"></param>
            <param name="lcid"></param>
            <returns>
            True if the node contains a language element with the specified name for the specified language
            </returns>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.ContainsLanguage(System.Int32)">
            <summary>
            Determine if a category contains a specific language.
            </summary>
            <param name="lcid"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.EmptyLanguageNode.ClearHierarchy">
            <summary>Empties all saved values in the node and its sub nodes</summary>
        </member>
        <member name="P:Fadd.Globalization.EmptyLanguageNode.Item(System.String)">
            <summary>
            Get a localized text string in the current language.
            </summary>
            <param name="textName">Phrase to find.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="P:Fadd.Globalization.EmptyLanguageNode.Item(System.String,System.Int32)">
            <summary>
            Get a localized text string
            </summary>
            <param name="lcid"></param>
            <param name="textName">Phrase to find.</param>
            <returns>text if found; [textName] if not.</returns>
            <example>
            <code>
            lang["Name"] // => "Name"
            lang["Naem"] // => "[Naem]" since it's missing
            </code>
            </example>
        </member>
        <member name="P:Fadd.Globalization.EmptyLanguageNode.Count">
            <summary>
            Number languages
            </summary>
        </member>
        <member name="T:Fadd.Commands.ICommandDispatcher">
            <summary>
            This is a bit more advanced command pattern. The regular command pattern
            ties the command to the the class that handles the command. This
            pattern removes that binding and makes the commands independent of
            the logic that executes it.
            <para>
            The pattern also allows multiple handlers for each command, and you
            can also add handlers for unhandled commands.
            </para>
            </summary>
            <example>
            // Map a handler to a command:
            distlight.Add(typeof(MyCommand), OnMyCommand);
            
            // invoke my command:
            if (!distlight.Invoke(new MyCommand(myUserId)))
              Console.WriteLine("No one handled the command!");
            
            </example>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Add(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Add a command handler.
            </summary>
            <param name="type">Must be a class, an attribute.</param>
            <param name="handler">handler handling the command</param>
            <exception cref="T:System.ArgumentException">If handler have been added to that type already.</exception>
            <example>
            Program.Commands.Add(typeof(MyCommand), OnMyCommand);
            </example>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Remove(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Remove a command handler.
            </summary>
            <param name="type">type to remove</param>
            <param name="handler">delegated that was mapped to the type.</param>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Invoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Invoke(Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Invoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Invoke(System.Object,Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.BeginInvoke(Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.BeginInvoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.BeginInvoke(System.Object,Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="source">object that is invoking the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.BeginInvoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="source">object that is invoking the command.</param>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.EndInvoke(System.IAsyncResult)">
            <summary>
            Invoke this method when the command is complete, or if you want to wait
            on the command.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.ICommandDispatcher.Contains(System.Type)">
            <summary>
            Tells us if we have a handler for the specified type.
            </summary>
            <param name="type">Type to check</param>
            <returns>True if a handler have been registered otherwise false.</returns>
        </member>
        <member name="E:Fadd.Commands.ICommandDispatcher.Unhandled">
            <summary>
            Handler for unhandled commands.
            </summary>
            <remarks>returning true will make the command look like it was handled</remarks>
        </member>
        <member name="T:Fadd.Check">
            <summary>
            Design by contract validator
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldRequired">
            <summary>
            "{0} must be specified."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldNotEqual">
            <summary>
            "'{0}' do not equal '{1}'."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldBetween">
            <summary>
            "'{0}' must be between {1} and {2}."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldBetweenStr">
            <summary>
            "'{0}' must be between {1} and {2} characters."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldMin">
            <summary>
            "'{0}' must be larger or equal to {1}."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldMinStr">
            <summary>
            "'{0}' must be larger or equal to {1}."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldTrue">
            <summary>
            "'{0}' must evaluate as true.
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldFalse">
            <summary>
            "'{0}' must evaluate as false.
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldMax">
            <summary>
            "'{0}' must be less or equal to {1}."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldMaxStr">
            <summary>
            "'{0}' must be less or equal to {1}."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldNotEmpty">
            <summary>
            "'{0}' must be specified and not empty."
            </summary>
        </member>
        <member name="F:Fadd.Check.FieldType">
            <summary>
            "'{1}' must be assignable from {0}."
            </summary>
        </member>
        <member name="F:Fadd.Check._language">
            <summary>
            Contains language information
            </summary>
        </member>
        <member name="M:Fadd.Check.True(System.Boolean,System.String)">
            <summary>
            The specified statement/parameter must be true.
            </summary>
            <param name="statement">statement/parameter to evaluate.</param>
            <param name="messageOrParamName">Name of the message or param.</param>
            <exception cref="T:Fadd.CheckException">If statement is not true.</exception>
        </member>
        <member name="M:Fadd.Check.False(System.Boolean,System.String)">
            <summary>
            The specified statement/parameter must be false.
            </summary>
            <param name="statement">statement/parameter to evaluate.</param>
            <param name="messageOrParamName">Name of the message or param.</param>
            <exception cref="T:Fadd.CheckException">If statement is true.</exception>
        </member>
        <member name="M:Fadd.Check.NotEqual(System.Object,System.Object,System.String)">
            <summary>
            Two values can't be equal.
            </summary>
            <param name="value">value/constant to compare to.</param>
            <param name="paramValue">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
            <remarks><paramref name="value"/> and <paramref name="paramValue"/> are both required.</remarks>
        </member>
        <member name="M:Fadd.Check.Between(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Value must be between (or equal) min and max
            </summary>
            <param name="min">minimum value.</param>
            <param name="max">maximum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Between(System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Betweens the specified min.
            </summary>
            <param name="min">minimum value.</param>
            <param name="max">maximum value.</param>
            <param name="value">parameter value to check. May not be null.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Between(System.Int32,System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Betweens the specified min.
            </summary>
            <param name="min">minimum value.</param>
            <param name="max">maximum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <param name="required"><paramref name="value"/> may be null if this parameter is false.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Min(System.DateTime,System.DateTime,System.String)">
            <summary>
            Checks if the value is equal or larger.
            </summary>
            <param name="min">minimum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Min(System.Int32,System.Int32,System.String)">
            <summary>
            Checks if the value is equal or larger.
            </summary>
            <param name="min">minimum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Min(System.Int64,System.Int64,System.String)">
            <summary>
            Checks if the value is equal or larger.
            </summary>
            <param name="min">minimum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Min(System.Int32,System.String,System.String)">
            <summary>
            Checks if the value is equal or larger.
            </summary>
            <param name="min">minimum value.</param>
            <param name="value">parameter value (may not be null).</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Min(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Checks if the value is equal or larger.
            </summary>
            <param name="min">minimum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <param name="required"><paramref name="value"/> may be null if this parameter is false.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Max(System.Int32,System.Int32,System.String)">
            <summary>
            Checks if the value is less or equal.
            </summary>
            <param name="max">maximum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Max(System.Int32,System.String,System.String)">
            <summary>
            Checks if the value is less or equal.
            </summary>
            <param name="max">maximum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Max(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Checks if the value is less or equal.
            </summary>
            <param name="max">maximum value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <param name="required"><paramref name="value"/> may be null if this parameter is false.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Max(System.DateTime,System.DateTime,System.String)">
            <summary>
            Checks if the value is less or equal.
            </summary>
            <param name="max">max value.</param>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Require(System.Object,System.String)">
            <summary>
            Parameter is required (may not be null).
            </summary>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.NotEmpty(System.String,System.String)">
            <summary>
            The specified string may not be null or empty.
            </summary>
            <param name="value">parameter value.</param>
            <param name="messageOrParamName">parameter name, or a error message.</param>
            <exception cref="T:Fadd.CheckException">If contract fails.</exception>
        </member>
        <member name="M:Fadd.Check.Type(System.Type,System.Object,System.String)">
            <summary>
            Check if the specified type can be assigned from the parameter type.
            </summary>
            <param name="type">Type that the parameter must be  (or derive/implement).</param>
            <param name="instance">instance</param>
            <param name="messageOrParamName">error message or parameter name</param>
        </member>
        <member name="P:Fadd.Check.Language">
            <summary>
            Contains language information
            </summary>
            <remarks>
            Language may only be specified once.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If language have been previously specified.</exception>
        </member>
        <member name="T:Fadd.CheckException">
            <summary>
            Exception thrown when a validation fails.
            </summary>
        </member>
        <member name="M:Fadd.CheckException.#ctor(System.String,System.String,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.CheckException"/> class.
            </summary>
            <param name="orgMessage">The original error message (have not been formatted).</param>
            <param name="msg">Formatted message.</param>
            <param name="arguments">Message arguments.</param>
        </member>
        <member name="M:Fadd.CheckException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.CheckException"/> class.
            </summary>
            <param name="orgMessage">The original error message (have not been formatted).</param>
            <param name="msg">Formatted message.</param>
        </member>
        <member name="P:Fadd.CheckException.OrgString">
            <summary>
            Unformatted error message, {0} have not been replaced with parameter name.
            </summary>
            <remarks>
            Can be used if you want to translate messages.
            </remarks>
        </member>
        <member name="P:Fadd.CheckException.Arguments">
            <summary>
            Arguments to string to format. First argument is parameter name.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.PropertyValue">
            <summary>
            Contains a value in a condition.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.IConditional">
            <summary>
            Used to identify conditions (used by Property to see it the text is a property or something else)
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.PropertyValue.#ctor(Fadd.Parser.SimpleSQL.Tokens.Property)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Tokens.PropertyValue"/> class.
            </summary>
            <param name="property">Property that this value belongs to.</param>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.PropertyValue.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>@[propertyName]</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.PropertyValue.TokenIdentifier">
            <summary>
            Identifier for this token.
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.PropertyValue.Property">
            <summary>
            Property that this token belongs to.
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.PropertyValue.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.MoreThan">
            <summary>
            >
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.MoreThan.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" &gt; "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.MoreThan.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.And">
            <summary>
            'AND' SQL token
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.And.ToString">
            <summary>
            SQL 'AND' text
            </summary>
            <returns>" AND "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.And.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreThanToken">
            <summary>
            Parse >=
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreThanToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreThanToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.ClassToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.ClassToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.FromToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.FromToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.InToken">
            <summary>
            An IN token.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.InToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.InToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Evaluator">
            <summary>
            Parses a condition string and compares it to an item
            </summary>
            <remarks>
            This class is NOT threadsafe.
            </remarks>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.Evaluator.Evaluator"/> class.
            </summary>
            <param name="conditionString">Conditions, should look like: "Age &gt;= ? AND FirstName == ?".</param>
            <param name="parameters">Parameters used in the condition, for instance 17 and Jonas in the example above.</param>
            <example>
            Evaluator = new Evaluator("FirstName = ? AND Age = ?", "Adam", 10});
            </example>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.Evaluator.Evaluator"/> class.
            </summary>
            <param name="conditionAndParameters">First index is conditions, the rest is parameters.</param>
            <example>
            Evaluator = new Evaluator(new object[]{"FirstName = ?", "Adam"});
            </example>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.Evaluate(System.Object)">
            <summary>
            Evaluates an instance.
            </summary>
            <param name="instance">The instance.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.Evaluate``1(System.Collections.Generic.IList{``0})">
            <summary>
            Go through a list and find all items.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.Evaluate(Fadd.Parser.Token)">
            <summary>
            Evaluate all tokens in the same level.
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Evaluator.CheckItem(Fadd.Parser.Token,System.Int32@)">
            <summary>
            Token should be a property name.
            </summary>
            <param name="token"></param>
            <param name="tokenIndex"></param>
            <returns></returns>
            <remarks>
            Will take three of the tokens (property CONDITION target) and evaluate them.
            </remarks>
            <exception cref="T:System.FormatException">If values can't be casted to property type</exception>
        </member>
        <member name="T:Fadd.Parser.Evaluator.MyType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.MyType.A">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.MyType.B">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Parser.Evaluator.TestUser">
            <summary>
            User used during testing.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.TestUser.FirstName">
            <summary>
            Gets or sets the first name.
            </summary>
            <value>The first name.</value>
        </member>
        <member name="P:Fadd.Parser.Evaluator.TestUser.LastName">
            <summary>
            Gets or sets the last name.
            </summary>
            <value>The last name.</value>
        </member>
        <member name="P:Fadd.Parser.Evaluator.TestUser.Age">
            <summary>
            Gets or sets the age.
            </summary>
            <value>The age.</value>
        </member>
        <member name="P:Fadd.Parser.Evaluator.TestUser.Status">
            <summary>
            Gets or sets the status.
            </summary>
            <value>The status.</value>
        </member>
        <member name="P:Fadd.Parser.Evaluator.TestUser.MyType">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Globalization.Yaml.YamlWatcher">
            <summary>
            Class to subscribe to change events on a file and update a language hierarchy every time the file changes.
            </summary>
            <remarks>
            If the file being watched is deleted or renamed no more changes will be made to the language node.
            Also be observant on the fact that the class cannot Remove entries from a <see cref="T:Fadd.Globalization.LanguageNode"/>, only add or modify entries.
            This restriction is needed because a single YamlWatcher only watches One file and a <see cref="T:Fadd.Globalization.LanguageNode"/> can be connected to several
            watchers and files, deleting anything could clear things for another file.
            </remarks>
        </member>
        <member name="T:Fadd.Globalization.ILanguageWatcher">
            <summary>
            Loads and watches language files on disk.
            </summary>
            <remarks>
            Future version can watch different file types, and load them using different loaders.
            </remarks>
        </member>
        <member name="M:Fadd.Globalization.ILanguageWatcher.Add(System.String)">
            <summary>
            Load and watch another file on disk.
            </summary>
            <param name="filename">Relative or absolute path to language file.</param>
            <returns>Node that have been loaded.</returns>
        </member>
        <member name="M:Fadd.Globalization.ILanguageWatcher.AddContents(System.String,System.String)">
            <summary>
            Parse YAML contents and add any language nodes to the watchers language
            </summary>
            <param name="yaml">YAML contents</param>
            <param name="nodeName">The name of the node to add the contents into</param>
            <returns>Node that have been loaded.</returns>
        </member>
        <member name="P:Fadd.Globalization.ILanguageWatcher.RootNode">
            <summary>
            Root language node.
            </summary>
        </member>
        <member name="F:Fadd.Globalization.Yaml.YamlWatcher._filesToReload">
            <summary>
            files that need to be reloaded
            </summary>
        </member>
        <member name="F:Fadd.Globalization.Yaml.YamlWatcher._readTimer">
            <summary>A timer to use as delay if the file is currently in use</summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.#ctor(Fadd.Globalization.LanguageNode,System.String)">
            <summary>
            Instantiates the class to listen to changes in a file, also reads the file and fills the language node with language entries
            </summary>
            <param name="languageNode">Language node to fill</param>
            <param name="filename">The filename to watch</param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the specified file does not exist</exception>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.Add(System.String)">
            <summary>
            Load and watch another file on disk.
            </summary>
            <param name="filename">Relative or absolute path to language file.</param>
            <returns>Node that have been loaded.</returns>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.AddContents(System.String,System.String)">
            <summary>
            Parse YAML contents and add any language nodes to the watchers language
            </summary>
            <param name="yaml">YAML contents</param>
            <param name="nodeName">The name of the node to add the contents into</param>
            <returns>Node that have been loaded.</returns>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.OnTryRead(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            Callback for when the file should be read again
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.Watch">
            <summary>
            Sets the class to watch the specified file
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.OnFileChanged(System.Object,System.IO.FileSystemEventArgs)">
            <summary>
            Callback for when the file changes
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.LoadFile(System.String)">
            <summary>
            Private loading of file to wrap read failure control
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.LoadFile(System.String,Fadd.Globalization.LanguageNode)">
            <summary>
            Fill the root node with languages and categories from the specified file
            </summary>
            <param name="fullPath">Full file path</param>
            <param name="rootNode">The root node to fill</param>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlWatcher.Dispose">
            <summary>
            Function to stop the watcher
            </summary>
        </member>
        <member name="P:Fadd.Globalization.Yaml.YamlWatcher.RootNode">
            <summary>
            Root language node.
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Data.Migration.IMigrationModel">
            <summary>
            Provides a general view of the model needed for saving migration data in the database
            </summary>
            <remarks>
            The model and mapping must be specified explicitly by the migration user since tables most oftenly
            should match a certain coding convention. Explicitly declaring the model also allows for saving 
            extra version data.
            </remarks>
        </member>
        <member name="P:Fadd.Data.Migration.IMigrationModel.VersionNumber">
            <summary>Gets or sets the version number of the migration</summary>
        </member>
        <member name="P:Fadd.Data.Migration.IMigrationModel.UpdateTime">
            <summary>Gets or sets the date and time for when the database was updated to the migration version</summary>
        </member>
        <member name="T:Fadd.Data.DataLayerException">
            <summary>
            Main exception in the data layer.
            </summary>
        </member>
        <member name="M:Fadd.Data.DataLayerException.#ctor(System.String,System.Data.Common.DbException)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayerException"/> class.
            </summary>
            <param name="msg">Error message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayerException"/> class.
            </summary>
            <param name="msg">Error message.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayerException"/> class.
            </summary>
            <param name="sql">SQL query that failed</param>
            <param name="msg">Error message.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerException.#ctor(System.String,System.String,System.Data.Common.DbException)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayerException"/> class.
            </summary>
            <param name="sql">SQL query that failed</param>
            <param name="msg">Error message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="P:Fadd.Data.DataLayerException.Sql">
            <summary>
            SQL query that failed.
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateRequiredAttribute">
            <summary>
            Checks whether a field have been specified or not.
            </summary>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>AlphaNumeric</term>
                    <description>'{0}' may only contain alpha numeric letters.</description>
                </item>
            </list>
            </para>
        </member>
        <member name="M:Fadd.Validation.ValidateRequiredAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateRequiredAttribute"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateRequiredAttribute.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateRequiredAttribute"/> class.
            </summary>
            <param name="emptyValue">value is considered to be not specified if the value matches this parameter.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateRequiredAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ValidateRequiredAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if type is supported.</returns>
            <remarks>
            Used when validation objects are generated.
            </remarks>
        </member>
        <member name="M:Fadd.Validation.ValidateRequiredAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="T:Fadd.Validation.ValidateHexAttribute">
            <summary>
            Validates that a string property represents valid Hex value (Value should not either too large or too small for an Int64).
            </summary>
        </member>
        <member name="F:Fadd.Validation.ValidateHexAttribute.Name">
            <summary>
            Name of the language item for this validation.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateHexAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">Thrown if the value supplied is not a <see cref="T:System.String"/></exception>
        </member>
        <member name="M:Fadd.Validation.ValidateHexAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>
            A localized error message if the validation failed; otherwise null.
            </returns>
            <example>
            	<code>
            attribute.Localize("FirstName", "'{0}' is required");
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateHexAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
            <remarks>
            Used when validation objects are generated.
            </remarks>
        </member>
        <member name="T:Fadd.Validation.ObjectValidator">
            <summary>
            Contains all validations for a certain type of object.
            </summary>
        </member>
        <member name="F:Fadd.Validation.ObjectValidator.CacheValidators">
            <summary>
            true if we should save a list with all generated validators, or generate new ones each time.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Create(System.Type)">
            <summary>
            Create a new validation object.
            </summary>
            <param name="type">Type of object to validate</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object,System.String)">
            <summary>
            Validate a specific property.
            </summary>
            <param name="instance">Instance to validate</param>
            <param name="propertyName">Name of property</param>
            <returns>A list with all validations that failed. Or an empty list of no validations failed.</returns>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object,System.Object,System.String)">
            <summary>
            Validate a specific property.
            </summary>
            <param name="context">An application specific context that's passed to all validation attributes. Useful if you've implemented your own validations.</param>
            <param name="instance">Instance to validate</param>
            <param name="propertyName">Name of property</param>
            <returns>
            A list with all validations that failed. Or an empty list of no validations failed.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object,System.String,System.Collections.Generic.IList{Fadd.Validation.ValidationError})">
            <summary>
            Validate a specific property.
            </summary>
            <param name="instance">Instance to validate</param>
            <param name="propertyName">Name of property</param>
            <param name="errors">List to fill with validation errors, must not be null.</param>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object,System.Object,System.String,System.Collections.Generic.IList{Fadd.Validation.ValidationError})">
            <summary>
            Validate a specific property.
            </summary>
            <param name="context">An application specific context that's passed to all validation attributes. Useful if you've implemented your own validations.</param>
            <param name="instance">Instance to validate</param>
            <param name="propertyName">Name of property</param>
            <param name="errors">List to fill with validation errors, must not be null.</param>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object)">
            <summary>
            Validate all properties in the object.
            </summary>
            <param name="instance">Instance to validate</param>
            <returns>A list with validation errors, or an empty list of all validations succeeded.</returns>
        </member>
        <member name="M:Fadd.Validation.ObjectValidator.Validate(System.Object,System.Object)">
            <summary>
            Validate all properties in the object.
            </summary>
            <param name="context">An application specific context that's passed to all validation attributes. Useful if you've implemented your own validations.</param>
            <param name="model">Instance to validate</param>
            <returns>A list with validation errors, or an empty list of all validations succeeded.</returns>
        </member>
        <member name="P:Fadd.Validation.ObjectValidator.Type">
            <summary>
            Type that this validator is for.
            </summary>
        </member>
        <member name="T:Fadd.Validation.BeforeValidationEventArgs">
            <summary>
            Used to be able to provide context to validation classes during validation.
            </summary>
        </member>
        <member name="M:Fadd.Validation.BeforeValidationEventArgs.#ctor(Fadd.Validation.ValidateAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.BeforeValidationEventArgs"/> class.
            </summary>
            <param name="attribute">Attribute that is going to be validated.</param>
        </member>
        <member name="P:Fadd.Validation.BeforeValidationEventArgs.Attribute">
            <summary>
            Attribute about to be used for validation.
            </summary>
        </member>
        <member name="P:Fadd.Validation.BeforeValidationEventArgs.Context">
            <summary>
            Context that should be passed to the validation class.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.IPluginInfo">
            <summary>
            Contains user information about a plugin.
            </summary>
            <remarks>
            Should be returned in the current language.
            </remarks>
            <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
        </member>
        <member name="P:Fadd.Plugins.IPluginInfo.Name">
            <summary>
            Name of the plugin, it should be in the local language if possible.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.IPluginInfo.Description">
            <summary>
            Description of what the plugin does. Shown to the end user.
            </summary>
            <remarks>
            The description may contain links to other pages and images.
            Just make sure that your controller can handle them.
            Links should be opened in new windows and not leave the market place.
            </remarks>
        </member>
        <member name="P:Fadd.Plugins.IPluginInfo.Homepage">
            <summary>
            Author homepage
            </summary>
        </member>
        <member name="P:Fadd.Plugins.IPluginInfo.Copyright">
            <summary>
            Copyright owner of this plugin.
            </summary>
        </member>
        <member name="T:Fadd.Globalization.MemLanguageNode">
            <summary>
            Contains translation texts that have been loaded into memory
            </summary>
        </member>
        <member name="F:Fadd.Globalization.MemLanguageNode._languages">
            <summary>
            int is LCID, NameValueCollection contains all phrases.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.#ctor(System.Int32,System.String)">
            <summary>Instantiates a LanguageNode that holds the language data in memory</summary>
            <param name="defaultLCID">The defualt language code</param>
            <param name="name">The name of the node</param>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.GetText(System.Int32,System.String)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.GetText(System.Int32,System.String,System.Boolean)">
            <summary>
            Get a text string in the specified language.
            </summary>
            <param name="lcid">Language to fetch from.</param>
            <param name="textName">name of text to find.</param>
            <param name="checkPaths">check for paths in <paramref name="textName"/>.</param>
            <returns>string if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.Add(System.String,System.Int32,System.String)">
            <summary>
            Adds a text entry to the language node
            </summary>
            <param name="name">Name of the entry</param>
            <param name="lcid">Language of the entry</param>
            <param name="text">The text of the entry</param>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.Set(System.String,System.Int32,System.String)">
            <summary>
            Sets a localized text string. If the a string with the specified name exists it will be overwritten.
            </summary>
            <param name="name">Name identifying the string. Used to fetch the string later on.</param>
            <param name="lcid">locale</param>
            <param name="text">Localized string</param>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.AddChild(System.String)">
            <summary>
            Adds a sub category
            </summary>
            <param name="name">Name of the sub category</param>
            <exception cref="T:System.ArgumentException">If a category with the specified name already exists</exception>
            <exception cref="T:System.ArgumentNullException">If name is null</exception>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.GetTextCount(System.Int32)">
            <summary>
            Returns number of text entries in the requested language
            </summary>
            <param name="lcid">The language to examine</param>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.Contains(System.String,System.Int32)">
            <summary>
            Determine if the node contains a text item with the specified name for the specified language
            </summary>
            <param name="name"></param>
            <param name="lcid"></param>
            <returns>
            True if the node contains a language element with the specified name for the specified language
            </returns>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.ContainsLanguage(System.Int32)">
            <summary>
            Determine if a category contains a specific language.
            </summary>
            <param name="lcid"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.MemLanguageNode.ClearHierarchy">
            <summary>Empties all saved values in the node and its subnodes</summary>
        </member>
        <member name="P:Fadd.Globalization.MemLanguageNode.Item(System.String)">
            <summary>Returns the requested entry using the systems current language</summary>
            <param name="textName">Name of the entry to retrieve</param>
            <returns>The entry or if not found in the current language, default language or in parent nodes returns [textName]</returns>
        </member>
        <member name="P:Fadd.Globalization.MemLanguageNode.Item(System.String,System.Int32)">
            <summary>
            A requested text entry in the requested language
            </summary>
            <param name="textName">Name of the entry to retrieve</param>
            <param name="lcid">Language code for the language to retrieve the text in</param>
            <returns>The entry or if not found in the current language, default language or in parent nodes returns [textName]</returns>
        </member>
        <member name="P:Fadd.Globalization.MemLanguageNode.Count">
            <summary>
            Returns the number of languages in the node
            </summary>
            <remarks>Returns the number of languages and Not text entries</remarks>
        </member>
        <member name="T:Fadd.Commands.Tests.MyCommand">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Commands.Command">
            <summary>
            A command that will be invoked
            </summary>
        </member>
        <member name="M:Fadd.Commands.Command.SetHandled(System.Boolean)">
            <summary>
            Set handled state.
            </summary>
            <param name="handled"></param>
        </member>
        <member name="P:Fadd.Commands.Command.IsHandled">
            <summary>
            true if the command have been handled.
            </summary>
            <remarks>Can be used to determine if another
            handler already have processed the command.</remarks>
        </member>
        <member name="M:Fadd.Commands.Tests.MyCommand.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Tests.MyCommand"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Fadd.Commands.Tests.MyCommand.Name">
            <summary>
            Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Fadd.Commands.Tests.MyAttr">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Commands.Tests.AllTypes">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Commands.Tests.DerivedCmd">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.DerivedCmd.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Tests.DerivedCmd"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="T:Fadd.Commands.Tests.myFace">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.AllTypes.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Tests.AllTypes"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="T:Fadd.Commands.Tests.UnknownCommand">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fadd.Commands.Tests.MyAttrCommand">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.MyAttrCommand.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Tests.MyAttrCommand"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Fadd.Commands.Tests.MyAttrCommand.Name">
            <summary>
            Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Fadd.Commands.Tests.MyFaceCmd">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.MyFaceCmd.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Tests.MyFaceCmd"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Fadd.Commands.Tests.MyFaceCmd.Name">
            <summary>
            Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.OrderBy">
            <summary>
            ORDER BY SQL Clause.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.OrderBy.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" ORDER BY "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.OrderBy.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Class">
            <summary>
            Class/Table name
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Class.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Tokens.Class"/> class.
            </summary>
            <param name="name">Name of class.</param>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Class.ToString">
            <summary>
            Returns SQL name
            </summary>
            <returns>Table name</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Class.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Class.Name">
            <summary>
            Name of class
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LikeToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LikeToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.MoreThanToken">
            <summary>
            Parse >=
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.MoreThanToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.MoreThanToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Data.Mappings.IMapping">
            <summary>
            Contains a mapping between a database table and a .Net class.
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.IMapping.GetColumnName(System.String)">
            <summary>
            Gets column name from a property name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Data.Mappings.IMapping.GetPrimaryKey">
            <summary>
            Gets current primary key.
            </summary>
            <returns>The primary key if exactly ONE is defined; otherwise null.</returns>
        </member>
        <member name="P:Fadd.Data.Mappings.IMapping.TableName">
            <summary>
            Gets table name.
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.IMapping.Type">
            <summary>
            Gets class type
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.IMapping.Properties">
            <summary>
            Gets all mapped properties
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.IMapping.PrimaryKeys">
            <summary>
            Gets all primary keys
            </summary>
        </member>
        <member name="T:Fadd.Data.Mappings.ColumnType">
            <summary>
            SQL92 column types.
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Bit">
            <summary>
            One bit
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.String">
            <summary>
            Short string
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Double">
            <summary>
            floating point
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Integer">
            <summary>
            Int column
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.DateTime">
            <summary>
            DateTime / Timestamp
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Date">
            <summary>
            Date only
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Time">
            <summary>
            Time only
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Boolean">
            <summary>
            Bool, int(1)
            </summary>
        </member>
        <member name="F:Fadd.Data.Mappings.ColumnType.Text">
            <summary>
            Long string
            </summary>
        </member>
        <member name="T:Fadd.Data.Mappings.ColumnHelper">
            <summary>
            Common operations for columns
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.ColumnHelper.ToType(Fadd.Data.Mappings.ColumnType)">
            <summary>
            Convert a column type to a .Net type
            </summary>
            <param name="type">column type to convert</param>
            <returns></returns>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyMethod">
            <summary>
            Class for building information strings about a proxy method
            </summary>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Instantiates a new object to parse and create readable data for a method
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.GetGenericName(System.Reflection.MethodInfo,System.String)">
            <summary>
            <![CDATA[
            Returns a full generic name if needed, ie GetThings<P, Q>
            ]]>
            </summary>
            <param name="info">The method to generate the name for</param>
            <param name="name">The methods name</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.GetTypedName(System.Reflection.MethodInfo,System.String)">
            <summary>
            Joins method name together with all parameter types creating an identifying string for the method
            </summary>
            <param name="info">The method to generate the name for</param>
            <param name="methodName">The method name</param>		
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.GenerateGetMethodCall(System.Reflection.MethodInfo,System.String)">
            <summary>
            Retrieves the call to Type.GetMethod needed to retrieve the method
            </summary>
            <param name="info">The method to retrieve</param>
            <param name="methodName">The correct name of the method to retrieve</param>
            <returns>
            ie. GetMethod("GetUser", new Type[]{typeof(Int32)})
            </returns>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.GetArgumentArray(System.Reflection.MethodInfo)">
            <summary>
            Retrieves a string representation of a list putting together all the parameters passed to the method in an object array
            </summary>
            <param name="info">The method for which to generate the argument array string</param>
            <returns>ie new object[]{value, argument}</returns>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyMethod.GetArgumentDeclaration(System.Reflection.MethodInfo,System.Collections.Generic.ICollection{System.Type})">
            <summary>
            Retrieves the argument list
            </summary>
            <param name="methodInfo">The method to generate the argument from</param>
            <param name="neededTypes">A list to which the methods needed types can be added</param>
            <returns>Ie GetData(int arg1, string arg4) => Int32 arg1, String arg4</returns>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.GetMethodCall">
            <summary>
            Retrieves a string representing the call to Type.GetMethods needed to retrieve the method
            </summary>
            <returns>
            ie. GetMethod("GetUserName", new Type[]{typeof(Int32), typeof(String)});
            </returns>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.ReturnType">
            <summary>
            Retrieves a string representation of the method return type
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.Name">
            <summary>
            Retrieves the name of a method
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.Signature">
            <summary>
            Retrieves a signature for the method, ie _getValuesInt32String
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.Declaration">
            <summary>
            Retrieves a string for declaring the ObjectProxy method in the form <see cref="F:Fadd.Commands.ObjectProxyMethod.MethodDeclaration"/>
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyMethod.NeededTypes">
            <summary>
            Retrieves a list of types the method depends on
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrderByPropertyToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrderByPropertyToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.IGenericLogger">
            <summary>
            Generic logger interface.
            </summary>
            <remarks>
            <para>Used since we do not want to force everyone to use the Fadd.Logging framework.
            Implement your own proxy to use your favorite logging mechanism
            </para>
            </remarks>
        </member>
        <member name="T:Fadd.MapHierarchy`2">
            <summary>
            A dictionary mapping not only values but also sub nodes of the same 
            <see cref="T:Fadd.MapHierarchy`2"/> type
            </summary>
        </member>
        <member name="M:Fadd.MapHierarchy`2.#ctor">
            <summary>
            Instances the <see cref="T:Fadd.MapHierarchy`2"/>
            </summary>
        </member>
        <member name="M:Fadd.MapHierarchy`2.#ctor(`0)">
            <summary>
            Instances the <see cref="T:Fadd.MapHierarchy`2"/> with a given name that can be used to identify the map later
            </summary>
            <param name="name">A unique name in a hierarchy to set for the map</param>
        </member>
        <member name="M:Fadd.MapHierarchy`2.Add(`0,`1)">
            <summary>
            Adds a value
            </summary>
            <param name="key">The key to map the value to</param>
            <param name="value">The value to add</param>
            <exception cref="T:System.ArgumentException">Thrown if a value has already been added with the given key</exception>
        </member>
        <member name="M:Fadd.MapHierarchy`2.Set(`0,`1)">
            <summary>
            Updates or adds a value defined by the specified key
            </summary>
            <param name="key">The key of the value to update or add</param>
            <param name="value">The value to set for the specified key</param>
        </member>
        <member name="M:Fadd.MapHierarchy`2.Remove(`0)">
            <summary>
            Removes a value specified by the given key from the <see cref="T:Fadd.MapHierarchy`2"/>
            </summary>
            <param name="key">The key to remove the value for</param>
            <returns>True if a value was removed</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.GetChild(`0)">
            <summary>
            Retrieves a child using a key
            </summary>
            <param name="key">The key the child is mapped to</param>
            <returns>Null if not found</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.Contains(`0)">
            <summary>
            Returns true if a value mapped to the given key is contained by the map
            </summary>
            <param name="key">Key the value is supposed to be mapped to</param>
            <returns>True if a key is found</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.ContainsValue(`1)">
            <summary>
            Returns true if a value is mapped
            </summary>
            <param name="value">The value to examine whether or not it is contained by the map</param>
            <returns>True if the value is found</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.ContainsMap(`0)">
            <summary>
            Returns true if a child exists that is mapped with the given key
            </summary>
            <param name="key">The key to examine child mappings for</param>
            <returns>True if a child is found</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.ContainsMap(Fadd.MapHierarchy{`0,`1})">
            <summary>
            Returns true if the map contains the specified child
            </summary>
            <param name="map">The map to examine whether or not it is contained</param>
            <returns>True if the map is a child of the instance</returns>
        </member>
        <member name="M:Fadd.MapHierarchy`2.RemoveChild(Fadd.MapHierarchy{`0,`1})">
            <summary>
            Removes a child if contained. Since the name set for the map will be used to remove the map a name must have been specified.
            </summary>
            <param name="map">The map to remove</param>
            <returns>True if the child was removed</returns>
            <remarks>If removed the <see cref="P:Fadd.MapHierarchy`2.Parent"/> will be set to null for the map</remarks>
        </member>
        <member name="M:Fadd.MapHierarchy`2.RemoveChild(`0)">
            <summary>
            Removes a child if contained
            </summary>
            <param name="key">The key or name of the child to remove</param>
            <returns>True if the child was removed</returns>
            <remarks>If removed the <see cref="P:Fadd.MapHierarchy`2.Parent"/> will be set to null for the map removed</remarks>
        </member>
        <member name="M:Fadd.MapHierarchy`2.AddChild(Fadd.MapHierarchy{`0,`1})">
            <summary>
            Adds a child to the <see cref="T:Fadd.MapHierarchy`2"/> using the name specified in <see cref="P:Fadd.MapHierarchy`2.Name"/>
            </summary>
            <param name="map">The map to add as a child, must have a defined se <see cref="P:Fadd.MapHierarchy`2.Name"/></param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the map is already a child of another <see cref="T:Fadd.MapHierarchy`2"/> instance, 
            it must be removed from there manually before being added to avoid hiding logical errors in code
            </exception>
        </member>
        <member name="M:Fadd.MapHierarchy`2.AddChild(Fadd.MapHierarchy{`0,`1},`0)">
            <summary>
            Adds a child to the <see cref="T:Fadd.MapHierarchy`2"/> using the name supplied
            </summary>
            <param name="map">The map to add as a child</param>
            <param name="key">The name to set for the map, will override any previous name</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the map is already a child of another <see cref="T:Fadd.MapHierarchy`2"/> instance, 
            it must be removed from there manually before being added to avoid hiding logical errors in code
            </exception>
        </member>
        <member name="M:Fadd.MapHierarchy`2.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through all the values contained by the map
            </summary>
        </member>
        <member name="M:Fadd.MapHierarchy`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through all the values contained by the map
            </summary>
        </member>
        <member name="P:Fadd.MapHierarchy`2.Item(`0)">
            <summary>
            Sets or gets a value held by the map
            </summary>
            <param name="key">Key mapping the value</param>
            <returns>Null if the value wasn't found</returns>
        </member>
        <member name="P:Fadd.MapHierarchy`2.Values">
            <summary>
            Retrieves all values held by the map
            </summary>
        </member>
        <member name="P:Fadd.MapHierarchy`2.Children">
            <summary>
            Retrieves all child <see cref="T:Fadd.MapHierarchy`2"/> held by the map
            </summary>
        </member>
        <member name="P:Fadd.MapHierarchy`2.Name">
            <summary>
            Retrieves the name identifying the map, is null if no name is set
            </summary>
        </member>
        <member name="P:Fadd.MapHierarchy`2.Parent">
            <summary>
            Retrieves any parent to the map, is null if no parent is set
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateEmailAttribute">
            <summary>
            Validates that a string property is an correct email.
            </summary>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>Email</term>
                    <description>'{0}' must be a valid email address.</description>
                </item>
            </list>
            </para>
        </member>
        <member name="M:Fadd.Validation.ValidateEmailAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize the error.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateEmailAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if type is supported.</returns>
            <remarks>
            Used when validation objects are generated.
            </remarks>
        </member>
        <member name="M:Fadd.Validation.ValidateEmailAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">Thrown if the object isn't a string</exception>
        </member>
        <member name="T:Fadd.Commands.IRemote">
            <summary>
            Tag commands with this interface to be able to transport them through the 
            CommandChannel.
            </summary>
        </member>
        <member name="M:Fadd.Commands.IRemote.CopyReply(Fadd.Commands.Command)">
            <summary>
            Copy all stuff that have been modified by the command handler.
            </summary>
            <param name="from">Command to copy reply from.</param>
        </member>
        <member name="T:Fadd.Commands.CommandManager">
            <summary>
            This is a bit more advanced command pattern. The regular command pattern
            ties the command to the the class that handles the command. This
            pattern removes that binding and makes the commands independent of
            the logic that executes it.
            <para>
            The pattern also allows multiple handlers for each command, and you
            can also add handlers for unhandled commands.
            </para>
            </summary>
            <example>
            <code>
            // Map a handler to a command:
            dispatcher.Add(typeof(MyCommand), OnMyCommand);
            
            // invoke my command:
            if (!dispatcher.Invoke(new MyCommand(myUserId)))
              Console.WriteLine("No one handled the command!");
            </code>
            </example>
        </member>
        <member name="F:Fadd.Commands.CommandManager.AsyncTimeout">
            <summary>
            When asynchronous invokes should be removed (if <see cref="M:Fadd.Commands.CommandManager.EndInvoke(System.IAsyncResult)"/> have not been called.)
            </summary>
        </member>
        <member name="F:Fadd.Commands.CommandManager._attributes">
            <summary>
            Attributes list used for commands that have not been mapped.
            </summary>
        </member>
        <member name="F:Fadd.Commands.CommandManager._classes">
            <summary>
            Classes/interfaces list used for command that have not been mapped.
            </summary>
        </member>
        <member name="F:Fadd.Commands.CommandManager._commandHandlers">
            <summary>
            Each command is mapped to different handlers 
            when the command is invoked. This is done once,
            then this list is used to invoke the commands (= speed increase)
            </summary>
        </member>
        <member name="F:Fadd.Commands.CommandManager._interfaces">
            <summary>
            Classes/interfaces list used for command that have not been mapped.
            </summary>
        </member>
        <member name="M:Fadd.Commands.CommandManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.CommandManager"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Commands.CommandManager.#ctor(Fadd.Commands.CommandManager,System.Boolean)">
            <summary>
            Create a new command manager
            </summary>
            <param name="parent">Parent manager, it will receive all commands that are
            invoked in this instance, or just all unhandled ones.</param>
            <param name="dispatchAll">true if all commands should be sent to the parent; otherwise just all unhandled will be sent.</param>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Add(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Add a command handler.
            </summary>
            <param name="type">Must be a class, an attribute.</param>
            <param name="handler">handler handling the command</param>
            <exception cref="T:System.ArgumentException">If handler have been added to that type already.</exception>
            <example>
            Program.Commands.Add(typeof(MyCommand), OnMyCommand);
            </example>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Remove(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Remove a command handler.
            </summary>
            <param name="type">type to remove</param>
            <param name="handler">delegated that was mapped to the type.</param>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Invoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Invoke(Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Invoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Invoke(System.Object,Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.BeginInvoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">Command to invoke</param>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.BeginInvoke(System.Object,Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="source">object that is invoking the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.CommandManager.BeginInvoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.CommandManager.BeginInvoke(Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.CommandManager.EndInvoke(System.IAsyncResult)">
            <summary>
            Invoke this method when the command is complete, or if you want to wait
            on the command.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.Contains(System.Type)">
            <summary>
            Tells us if we have a handler for the specified type.
            </summary>
            <param name="type">Type to check</param>
            <returns>True if a handler have been registered otherwise false.</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.TriggerUnhandled(Fadd.Commands.Command)">
            <summary>
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.InvokePropagationCancelled(Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            A command handler have canceled a command, this event gives you a chance to
            ignore that cancellation.
            </summary>
            <param name="command">command that was canceled.</param>
            <param name="handler">handler that canceled the command.</param>
            <returns>true means that we can cancel; false that we should continue</returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.AddNewCommand(Fadd.Commands.Command)">
            <summary>
            Map a command that have never been mapped.
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.CommandManager.MapCommand(Fadd.Commands.Command,System.Collections.Generic.ICollection{Fadd.Commands.CommandHandler})">
            <summary>
            Map a command to all handlers.
            this is done to speed up the invoke process.
            </summary>
            <param name="command"></param>
            <param name="handlers"></param>
        </member>
        <member name="E:Fadd.Commands.CommandManager.PropagationCancelled">
            <summary>
            Event that can override the <see cref="P:Fadd.Commands.CommandEventArgs.CancelPropagation"/> property.
            </summary>
            <seealso cref="T:Fadd.Commands.PropagationHandler"/>
        </member>
        <member name="E:Fadd.Commands.CommandManager.Unhandled">
            <summary>
            Handler for unhandled commands.
            </summary>
            <remarks>returning true will make the command look like it was handled</remarks>
        </member>
        <member name="T:Fadd.Commands.AsyncQueueItemResult">
            <summary>
            Used to keep track of all asynchronous commands.
            </summary>
        </member>
        <member name="P:Fadd.Commands.AsyncQueueItemResult.IsCompleted">
            <summary>
            Gets an indication whether the asynchronous operation has completed.
            </summary>
            
            <returns>
            true if the operation is complete; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Fadd.Commands.AsyncQueueItemResult.AsyncWaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"></see> that is used to wait for an asynchronous operation to complete.
            </summary>
            
            <returns>
            A <see cref="T:System.Threading.WaitHandle"></see> that is used to wait for an asynchronous operation to complete.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Fadd.Commands.AsyncQueueItemResult.AsyncState">
            <summary>
            Gets a user-defined object that qualifies or contains information about an asynchronous operation.
            </summary>
            
            <returns>
            A user-defined object that qualifies or contains information about an asynchronous operation.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Fadd.Commands.AsyncQueueItemResult.CompletedSynchronously">
            <summary>
            Gets an indication of whether the asynchronous operation completed synchronously.
            </summary>
            
            <returns>
            true if the asynchronous operation completed synchronously; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.IsNotNull">
            <summary>
            Corresponds to "IS NOT NULL".
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.IsNotNull.ToString">
            <summary>
            " IS NOT NULL"
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.IsNotNull.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Equal">
            <summary>
            =
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Equal.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" = "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Equal.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Comma">
            <summary>
            Represents a comma
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Comma.ToString">
            <summary>
            Conditional string
            </summary>
            <returns>", "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Comma.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrderByToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrderByToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.Property">
            <summary>
            A property name
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.Property.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.Evaluator.Tokens.Property"/> class.
            </summary>
            <param name="name">Name of property.</param>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.Property.ToString">
            <summary>
            Returns name of property
            </summary>
            <returns>name of property</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.Property.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.Property.Name">
            <summary>
            Name of property
            </summary>
        </member>
        <member name="T:Fadd.Data.Migration.MigrationXmlException">
            <summary>Specific exception for errors occured during xml handling</summary>
        </member>
        <member name="T:Fadd.Data.Migration.MigrationException">
            <summary>Describes an exception occured during migration of database</summary>
        </member>
        <member name="M:Fadd.Data.Migration.MigrationException.#ctor(System.String)">
            <summary>Initializes the exception with a message</summary>
            <param name="message">The exception message describing the error occured</param>
        </member>
        <member name="M:Fadd.Data.Migration.MigrationException.#ctor(System.String,System.Exception)">
            <summary>Initializes the exception with a message</summary>
            <param name="message">The exception message describing the error occured</param>
            <param name="innerException">The exception triggering the throwing of this exception</param>
        </member>
        <member name="M:Fadd.Data.Migration.MigrationXmlException.#ctor(System.String)">
            <summary>Initializes the <see cref="T:Fadd.Data.Migration.MigrationXmlException"/></summary>
            <param name="message">Error message to display</param>
        </member>
        <member name="M:Fadd.Data.Migration.MigrationXmlException.#ctor(System.String,System.Exception)">
            <summary>Initializes the <see cref="T:Fadd.Data.Migration.MigrationXmlException"/></summary>
            <param name="message">Error message to display</param>
            <param name="innerException">Exception that brought the throwing of the xml exception</param>
        </member>
        <member name="M:Fadd.Data.Migration.MigrationXmlException.#ctor(System.String[])">
            <summary>Initializes the <see cref="T:Fadd.Data.Migration.MigrationXmlException"/></summary>
            <param name="messages">Error messages to display</param>
        </member>
        <member name="P:Fadd.Data.Migration.MigrationXmlException.OriginalMessage">
            <summary>Retrieves the error messages not prepended with readable error string</summary>
        </member>
        <member name="T:Fadd.Data.ConnectionHelpers.SqlServerHelper">
            <summary>
            Connection helper for SQL Server.
            </summary>
        </member>
        <member name="T:Fadd.Data.IConnectionHelper">
            <summary>
            Used 
            </summary>
        </member>
        <member name="M:Fadd.Data.IConnectionHelper.CreateConnection">
            <summary>
            Create a new connection to the database.
            </summary>
            <returns>An open database connection.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If connection fails.</exception>
        </member>
        <member name="M:Fadd.Data.IConnectionHelper.GetNextSequenceValue(System.Data.IDbCommand,System.String)">
            <summary>
            Try to get next sequence value.
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction.</param>
            <param name="sequenceName">Name of the sequence/generator.</param>
            <returns>A generated value.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
        </member>
        <member name="M:Fadd.Data.IConnectionHelper.GetAutoIncrementValue(System.Data.IDbCommand,System.String)">
            <summary>
            Gets the latest auto incremented value from the database.
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction..</param>
            <param name="columnName">Name of the column that the auto incremented value is for.</param>
            <returns>auto incremented value</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
        </member>
        <member name="M:Fadd.Data.IConnectionHelper.Paging(Fadd.Data.Mappings.IMapping,System.String,System.Int32,System.Int32)">
            <summary>
            Modifies the SQL statement to include paging.
            </summary>
            <param name="mapping">Database mapping</param>
            <param name="sqlStatement">SQL statement generated by the DAL.</param>
            <param name="page">0 based index</param>
            <param name="pageSize">number of entries per page</param>
            <returns>SQL statement with paging</returns>
            <example>
            <code>
            helper.Paging("SELECT * FROM users", 5, 10); // --> "SELECT * FROM users LIMIT 10 OFFSET 50"
            </code>
            </example>
        </member>
        <member name="P:Fadd.Data.IConnectionHelper.ConnectionString">
            <summary>
            Connection string
            </summary>
        </member>
        <member name="P:Fadd.Data.IConnectionHelper.ParameterPrefix">
            <summary>
            Gets the paramter prefix
            </summary>
            <example>
            For SQL @
            For MySQL ?
            For Oracle :
            </example>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.SqlServerHelper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.ConnectionHelpers.SqlServerHelper"/> class.
            </summary>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.SqlServerHelper.CreateConnection">
            <summary>
            Create a new connection to the database.
            </summary>
            <returns>An open database connection.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If connection fails.</exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.SqlServerHelper.GetNextSequenceValue(System.Data.IDbCommand,System.String)">
            <summary>
            Try to get
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction.</param>
            <param name="sequenceName">Name of the sequence/generator.</param>
            <returns>A generated value.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
            <exception cref="T:System.NotSupportedException">SQL Server do not support sequences.</exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.SqlServerHelper.GetAutoIncrementValue(System.Data.IDbCommand,System.String)">
            <summary>
            Gets the latest auto incremented value from the database.
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction..</param>
            <param name="columnName">Name of the column that the auto incremented value is for.</param>
            <returns>auto incremented value</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.SqlServerHelper.Paging(Fadd.Data.Mappings.IMapping,System.String,System.Int32,System.Int32)">
            <summary>
            Modifies the SQL statement to include paging.
            </summary>
            <param name="mapping">Used to generate SQL Servers wierd paging method.</param>
            <param name="sqlStatement">SQL statement generated by the DAL.</param>
            <param name="page">0 based index</param>
            <param name="pageSize">number of entries per page</param>
            <returns>SQL statement with paging</returns>
            <example>
            	<code>
            helper.Paging("SELECT * FROM users", 5, 10); // --&gt; "SELECT * FROM users LIMIT 10 OFFSET 50"
            </code>
            </example>
            <remarks>
            Only SQL Server 2005 and above is supported.
            </remarks>
        </member>
        <member name="P:Fadd.Data.ConnectionHelpers.SqlServerHelper.ConnectionString">
            <summary>
            Connection string
            </summary>
            <value></value>
        </member>
        <member name="P:Fadd.Data.ConnectionHelpers.SqlServerHelper.ParameterPrefix">
            <summary>
            Gets the paramter prefix
            </summary>
            <value>Will return a @</value>
        </member>
        <member name="T:Fadd.Validation.ValidateAlphaNumericAttribute">
            <summary>
            Validates that a string only contains letter, digits and any of: <![CDATA['"\<>|-_.:,;'^~¨'*!#¤%&/()=?`´+}][{€$££@§½ ]]>
            </summary>
            <remarks>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>AlphaNumeric</term>
                    <description>'{0}' may only contain alpha numeric letters.</description>
                </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:Fadd.Validation.ValidateLettersAndDigitsAttribute">
            <summary>
            Input may only be letters and digits, foreign chars (for instance åäö) etc are included.
            </summary>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>LettersAndDigits</term>
                    <description>'{0}' may only contain letters and digits.</description>
                </item>
                <item>
                    <term>LettersAndDigitsExtra</term>
                    <description>'{0}' may only contain letters. digits and '{1}'.</description>
                </item>
            </list>
            </para>
        </member>
        <member name="F:Fadd.Validation.ValidateLettersAndDigitsAttribute.ForeignCharacters">
            <summary>
            Foreign characters (letters used for instance in the Swedish language)
            </summary>
        </member>
        <member name="F:Fadd.Validation.ValidateLettersAndDigitsAttribute.ForeignCharactersSDC">
            <summary>
            Foreign characters (letters used for instance in the Swedish language) and space, dot and comma.
            </summary>
        </member>
        <member name="F:Fadd.Validation.ValidateLettersAndDigitsAttribute.SDC">
            <summary>
            Space, dot and comma.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateLettersAndDigitsAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateLettersAndDigitsAttribute"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateLettersAndDigitsAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateLettersAndDigitsAttribute"/> class.
            </summary>
            <param name="extraCharacters">The extra characters.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateLettersAndDigitsAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">Only strings are valid for this type.</exception>
        </member>
        <member name="M:Fadd.Validation.ValidateLettersAndDigitsAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateLettersAndDigitsAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if type is supported.</returns>
            <remarks>
            Used when validation objects are generated.
            </remarks>
        </member>
        <member name="P:Fadd.Validation.ValidateLettersAndDigitsAttribute.ExtraCharacters">
            <summary>
            Gets the extra characters.
            </summary>
            <value>The extra characters.</value>
        </member>
        <member name="M:Fadd.Validation.ValidateAlphaNumericAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateAlphaNumericAttribute"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateAlphaNumericAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateAlphaNumericAttribute"/> class.
            </summary>
            <param name="extraCharacters">The extra characters.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateAlphaNumericAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="T:Fadd.Validation.LocalizedValidator">
            <summary>
            Does validation using the current language.
            </summary>
            <remarks>
            This class is thread safe, meaning that you can have multiple threads using it at the same time.
            </remarks>
        </member>
        <member name="M:Fadd.Validation.LocalizedValidator.#ctor(Fadd.Globalization.ILanguageNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.LocalizedValidator"/> class.
            </summary>
            <param name="validationLanguage">Node with the validation language.</param>
        </member>
        <member name="M:Fadd.Validation.LocalizedValidator.Localize(System.Collections.Generic.IEnumerable{Fadd.Validation.ValidationError},Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize all error messages.
            </summary>
            <param name="errors">A list with validation errors.</param>
            <param name="modelLanguage"><see cref="T:Fadd.Globalization.LanguageNode"/> containing language strings for the validated model.</param>
            <returns>A list with localized errors; or an empty list if no validations failed.</returns>
        </member>
        <member name="M:Fadd.Validation.LocalizedValidator.Validate(System.Object,System.Object,Fadd.Globalization.ILanguageNode)">
            <summary>
            Validates a model and returns errors in the current language.
            </summary>
            <remarks>
            Current language are decided by <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.
            </remarks>
            <param name="context">An application specific context that's passed to all validation attributes. Useful if you've implemented your own validations.</param>
            <param name="model">Model being validated.</param>
            <param name="language">Language node for the model.</param>
            <returns>A collection with all validations that failed; an empty collection if not validations failed.</returns>
        </member>
        <member name="T:Fadd.Commands.FilteredDispatcher">
            <summary>
            <para>
            This dispatcher is used to be able to specify which commands that can be invoked.
            </para>
            </summary>
            <remarks>
            <para>
            A typical usage would be if you have a plugin system and you do not want to allow
            all plugins to be able to execute all commands. Then you create a proxy dispatcher
            and expose it to the plugins, instead of the core dispatcher which contains all command 
            mappings. In this way, your core system it still protected while plugins can access
            a subset of it.
            </para>
            </remarks>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.#ctor(Fadd.Commands.ICommandDispatcher,System.Collections.Generic.List{System.Type},System.Collections.Generic.List{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.FilteredDispatcher"/> class.
            </summary>
            <param name="parent">Parent dispatcher (that is used by the rest of the system).</param>
            <param name="executeCommands">Commands that may be invoked.</param>
            <param name="handledCommands">Commands that may be handled.</param>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.#ctor(Fadd.Commands.ICommandDispatcher)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.FilteredDispatcher"/> class.
            </summary>
            <param name="parent">Parent dispatcher (that is used by the rest of the system).</param>
            <remarks>No commands are allowed unless you use the <see cref="E:Fadd.Commands.FilteredDispatcher.InvokeRequested"/> event.</remarks>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Add(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Add a command handler.
            </summary>
            <param name="type">Must be a class, an attribute.</param>
            <param name="handler">handler handling the command</param>
            <exception cref="T:System.ArgumentException">If handler have been added to that type already.</exception>
            <exception cref="T:System.InvalidOperationException">The specified command may not be handled.</exception>
            <example>
            Program.Commands.Add(typeof(MyCommand), OnMyCommand);
            </example>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Remove(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Remove a command handler.
            </summary>
            <param name="type">type to remove</param>
            <param name="handler">delegated that was mapped to the type.</param>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Invoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Invoke(Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
            <exception cref="T:System.InvalidOperationException">If you may not invoke the specified command.</exception>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Invoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Invoke a command.
            </summary>
            <param name="command">command to invoke.</param>
            <param name="ignoreMe">Handled that should not be invoked.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Invoke(System.Object,Fadd.Commands.Command)">
            <summary>
            Invoke a command.
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">command to invoke.</param>
            <returns>true if command was handled.</returns>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.BeginInvoke(System.Object,Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="source">object that is invoking the command.</param>
            <param name="command">Command to invoke</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <exception cref="T:System.InvalidOperationException">If you may not invoke the specified command.</exception>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.BeginInvoke(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <param name="source">object that is invoking the command.</param>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.BeginInvoke(Fadd.Commands.Command,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.BeginInvoke(Fadd.Commands.Command,Fadd.Commands.CommandHandler,System.AsyncCallback,System.Object)">
            <summary>
            Invoke a command asynchronously
            </summary>
            <param name="command">Command to invoke</param>
            <returns>IAsyncResult if command was invoked successfully; otherwise null.</returns>
            <param name="ignoreMe">Handler that should not receive the command.</param>
            <param name="callback">Callback that is invoked then the command completes.</param>
            <param name="state">object that you can use to identify the command in the <see cref="T:System.AsyncCallback"/>-method.</param>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.EndInvoke(System.IAsyncResult)">
            <summary>
            Invoke this method when the command is complete, or if you want to wait
            on the command.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.FilteredDispatcher.Contains(System.Type)">
            <summary>
            Tells us if we have a handler for the specified type.
            </summary>
            <param name="type">Type to check</param>
            <returns>True if a handler have been registered otherwise false.</returns>
        </member>
        <member name="E:Fadd.Commands.FilteredDispatcher.UnhandledExceptionThrown">
            <summary>
            Occurs when an unhandled exception have been caught.
            </summary>
        </member>
        <member name="E:Fadd.Commands.FilteredDispatcher.AddRequested">
            <summary>
            This event is invoked when someone tries to add a handler for a command.
            </summary>
        </member>
        <member name="E:Fadd.Commands.FilteredDispatcher.InvokeRequested">
            <summary>
            This event is invoked when someone tries to invoke a command.
            </summary>
        </member>
        <member name="E:Fadd.Commands.FilteredDispatcher.Unhandled">
            <summary>
            Handler for unhandled commands.
            </summary>
            <remarks>returning true will make the command look like it was handled</remarks>
        </member>
        <member name="T:Fadd.Commands.MappedCommand">
            <summary>
            A mapped command have been assigned all subscribers that 
            have been mapped to an interface, subclass, or attribute
            that the command contains.
            </summary>
        </member>
        <member name="P:Fadd.Commands.MappedCommand.Handlers">
            <summary>
            All delegates that will be invoked for this command.
            </summary>
        </member>
        <member name="P:Fadd.Commands.MappedCommand.Dirty">
            <summary>
            Dirty means that a new handler have been added since
            the command was last invoked.
            This means that we need to recheck whether we got all
            handlers.
            </summary>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyGenerator">
            <summary>
            Generates Object proxies.
            </summary>
            <todo>
            Name the proxies with generic types to allow multiple generic types ie ListInt32Proxy and ListStringProxy.
            Pretty up the use of properties a bit.
            Add tests for interface hierarchies and properties.
            Add support for events in interfaces.
            </todo>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyGenerator.#ctor(Fadd.Commands.ICommandDispatcher)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.ObjectProxyGenerator"/> class.
            </summary>
            <param name="dispatcher">Dispatcher used to send events.</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyGenerator.Generate(System.Type)">
            <summary>
            Generate an object proxy
            </summary>
            <param name="type">Type to generate a proxy for</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyGenerator.Compile(System.Type,System.String)">
            <summary>
            Compiles the proxy type declaration string that has been build
            </summary>
            <param name="type">The type from which to create a proxy</param>
            <param name="code">The code to compile</param>
            <returns>The compiled object or null if it couldn't be created</returns>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyGenerator.AddProperties(System.Type)">
            <summary>
            Add all properties
            </summary>
            <param name="interfaceType"></param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyGenerator.BuildClassText(System.Type)">
            <summary>
            Build code for a proxy class.
            </summary>
            <param name="type">Type to build code for.</param>
            <returns>a complete class (in text).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.LessThan">
            <summary>
            <![CDATA[
            <
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.LessThan.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" &lt; "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.LessThan.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyValueToken">
            <summary>
            Contains a property value
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyValueToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyValueToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrToken">
            <summary>
            Parse a OR token
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.OrToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyValueToken">
            <summary>
            Contains a property value
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyValueToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyValueToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Data.ITransaction">
            <summary>
            Database transaction.
            </summary>
            <remarks>
            Makes it possible to save a lot of changes only
            if all changes can succeed.
            </remarks>
        </member>
        <member name="T:Fadd.Data.IDataLayer">
            <summary>
            Base interface.
            </summary>
        </member>
        <member name="M:Fadd.Data.IDataLayer.CreateTransaction(System.Data.IsolationLevel)">
            <summary>
            Creates a new transaction.
            </summary>
            <param name="level">On of the <see cref="T:System.Data.IsolationLevel"/>s.</param>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="M:Fadd.Data.IDataLayer.CreateTransaction">
            <summary>
            Creates a new transaction.
            </summary>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Query``1(System.String,System.Object[])">
            <summary>
            Get a single object.
            </summary>
            <typeparam name="T">Type of object to fetch</typeparam>
            <param name="statement">complete SQL statement with class/properties instead of table/columns.</param>
            <param name="parameters">parameters used in the statement.</param>
            <returns>object if found; otherwise null</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Execute``1(System.String,System.Object[])">
            <summary>
            Executes an statement in the database.
            </summary>
            <typeparam name="T">Type of object to fetch</typeparam>
            <param name="statement">complete SQL statement with class/properties instead of table/columns.</param>
            <param name="parameters">parameters used in the statement.</param>
            <returns>object if found; otherwise null</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Get``1(System.String,System.Object[])">
            <summary>
            Get a single object.
            </summary>
            <typeparam name="T">Type of object to fetch.</typeparam>
            <param name="conditions">Conditions (corresponds to statements in the WHERE clause).</param>
            <param name="parameters">Parameters used in the where clause.</param>
            <returns>object if found; otherwise null.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.GetById``1(System.Object)">
            <summary>
            Get a single object using its primary key
            </summary>
            <typeparam name="T">Type of object to fetch, must have a defined mapping.</typeparam>
            <param name="id">Primary key value</param>
            <returns>object if found; otherwise null.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Find``1(System.String,System.Object[])">
            <summary>
            Retrieves a collection of items.
            </summary>
            <typeparam name="T">Type of item to get.</typeparam>
            <param name="conditions">Conditions to limit.</param>
            <param name="parameters">Parameters used in the condition.</param>
            <returns>A list of objects; or an empty list</returns>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Find``1">
            <summary>
            Retrieves all items of a certain type.
            </summary>
            <typeparam name="T">Type of item to get.</typeparam>
            <returns>A list of objects; or an empty list</returns>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Find``1(Fadd.Data.Statement)">
            <summary>
            Gets all items defined by the <see cref="T:Fadd.Data.Statement"/>.
            </summary>
            <typeparam name="T">type of items to get.</typeparam>
            <param name="statement">Statement specifying which elements to get.</param>
            <returns>A list of elements.</returns>
        </member>
        <member name="M:Fadd.Data.IDataLayer.FindBySQL``1(System.String,System.Object[])">
            <summary>
            Execute a custom SQL query (Object SQL can not be used yet).
            </summary>
            <typeparam name="T">type of items to get.</typeparam>
            <param name="query">SQL query.</param>
            <param name="parameters">Parameters used in the query.</param>
            <returns>A list of elements.</returns>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Save(System.Object)">
            <summary>
            Save or update an object in the database (1. Checks if the PK is empty. 2. Checks if the object exists in the db).
            </summary>
            <param name="value">Value to create/update.</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Create(System.Object)">
            <summary>
            Create a new object in the database.
            </summary>
            <param name="value">Object to create.</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Update(System.Object)">
            <summary>
            Update an existing object.
            </summary>
            <param name="value">Object to update</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.ExistsById``1(System.Object)">
            <summary>
            Checks if an object exists by using it's primary key.
            </summary>
            <typeparam name="T">Type of object to check</typeparam>
            <param name="id">Primary key</param>
            <returns>true if object was found; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Exists(System.Object)">
            <summary>
            Checks if an object exists by providing it.
            </summary>
            <param name="model">object to check</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Exists``1(System.String,System.Object[])">
            <summary>
            Checks if an object exists in the database
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <param name="conditions">Conditions.</param>
            <param name="arguments">Arguments used in the conditions.</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Count``1(System.String,System.Object[])">
            <summary>
            Count number of items.
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <param name="conditions">Conditions.</param>
            <param name="arguments">Arguments used in the conditions.</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Count``1">
            <summary>
            Count number of items.
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.CountBySQL(System.String)">
            <summary>
            Counts by SQL. Write the whole statement yourself.
            </summary>
            <param name="sql">The statement.</param>
            <returns>Number of returned rows</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.RemoveById``1(System.Object)">
            <summary>
            Removes an object by using it's id property.
            </summary>
            <typeparam name="T">Type of object to remove.</typeparam>
            <param name="id">Primary key value</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">RemoveById requires exactly one primary key.</exception>
        </member>
        <member name="M:Fadd.Data.IDataLayer.Remove``1(System.String,System.Object[])">
            <summary>
            Removes an object by using it's id property.
            </summary>
            <typeparam name="T">Type of object to remove.</typeparam>
        </member>
        <member name="P:Fadd.Data.IDataLayer.MappingProviders">
            <summary>
            Gets class that takes care of all providers.
            </summary>
        </member>
        <member name="P:Fadd.Data.IDataLayer.Logger">
            <summary>
            Gets logger instance.
            </summary>
        </member>
        <member name="M:Fadd.Data.ITransaction.Cancel">
            <summary>
            Cancel all changes made with the transaction.
            </summary>
            <remarks>
            Cancel will be called by Dispose if commit have
            not been called before the transaction is disposed.
            </remarks>
        </member>
        <member name="M:Fadd.Data.ITransaction.Commit">
            <summary>
            Write all changes to the database.
            </summary>
        </member>
        <member name="T:Fadd.Data.CompiledStatement">
            <summary>
            Contains a compiled SQL statements.
            </summary>
            <remarks>
            "Compiled" means that we've converted the statement from ObjectSQL
            to real SQL with table and column names.
            </remarks>
        </member>
        <member name="M:Fadd.Data.CompiledStatement.#ctor(Fadd.Data.Mappings.IMapping,System.String,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.CompiledStatement"/> class.
            </summary>
            <param name="mapping">Mapping between columns and properties</param>
            <param name="sql">SQL statement.</param>
            <param name="properties">Properties that have been selected. null if no properties have been specified.</param>
            <param name="arguments">Arguments used in the SQL statement..</param>
        </member>
        <member name="M:Fadd.Data.CompiledStatement.CreateWrapper(System.String)">
            <summary>
            Create a new statement with specialized SQL.
            </summary>
            <param name="sql">SQL string</param>
            <returns>New statement.</returns>
        </member>
        <member name="P:Fadd.Data.CompiledStatement.Arguments">
            <summary>
            Gets properties that are used as arguments to the statement.
            </summary>
        </member>
        <member name="P:Fadd.Data.CompiledStatement.Sql">
            <summary>
            Gets SQL statement.
            </summary>
        </member>
        <member name="P:Fadd.Data.CompiledStatement.Mapping">
            <summary>
            Gets mappings between columns and properties.
            </summary>
        </member>
        <member name="P:Fadd.Data.CompiledStatement.Properties">
            <summary>
            Gets properties that have been selected. 
            </summary>
            <remarks>
            null if no properties have been specified.
            </remarks>
        </member>
        <member name="T:Fadd.Plugins.PluginTypeInfo">
            <summary>
            A found plugin and which of the requested types that it implements.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginTypeInfo.#ctor(System.String,System.Type,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.PluginTypeInfo"/> class.
            </summary>
            <param name="assemblyLocation">assembly that the plugin resides in.</param>
            <param name="type">plugin type.</param>
            <param name="publicKey">assemblies public key. should be used to decide the amount of access for the module.</param>
        </member>
        <member name="M:Fadd.Plugins.PluginTypeInfo.Add(System.Type)">
            <summary>
            Add another type
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:Fadd.Plugins.PluginTypeInfo.PublicKey">
            <summary>
            Assemblies public key if signed.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginTypeInfo.Assembly">
            <summary>
            Assembly full path
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginTypeInfo.Location">
            <summary>
            Location of DLL.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginTypeInfo.Types">
            <summary>
            Requested types that exists in the assembly
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginTypeInfo.PublicKeyRaw">
            <summary>
            Assembly public key in byte format.
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.DisconnectedEventArgs">
            <summary>
            Arguments for <see cref="T:Fadd.Commands.Net.DisconnectedHandler"/>
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.DisconnectedEventArgs.#ctor(System.Net.Sockets.SocketError)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.DisconnectedEventArgs"/> class.
            </summary>
            <param name="error">Why we were disconnected.</param>
            <remarks>SocketError.Success means that we disconnected due to invalid data/packet from the remote end.</remarks>
        </member>
        <member name="P:Fadd.Commands.Net.DisconnectedEventArgs.Error">
            <summary>
            Why we were disconnected.
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.DisconnectedHandler">
            <summary>
            Called when a connection have been closed.
            </summary>
            <param name="source">Socket/Tunnel/Channel</param>
            <param name="args">Why it was disconnected.</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Delete">
            <summary>
            DELETE FROM clause
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.From">
            <summary>
            FROM SQL clause
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.From.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" FROM "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.From.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Delete.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>"DELETE FROM "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Delete.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreOrEqualToken">
            <summary>
            Parse >=
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreOrEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.MoreOrEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.InToken">
            <summary>
            An IN token.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.InToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.InToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Globalization.DurationDetail">
            <summary>
            Enumeration specifying a detail level in which to display a duration
            </summary>
        </member>
        <member name="F:Fadd.Globalization.DurationDetail.Months">
            <summary>
            Display duration in months and years
            </summary>
        </member>
        <member name="F:Fadd.Globalization.DurationDetail.Days">
            <summary>
            Display duration in days, months and years
            </summary>
        </member>
        <member name="F:Fadd.Globalization.DurationDetail.Hours">
            <summary>
            Display duration in hours, days, months and years
            </summary>
        </member>
        <member name="F:Fadd.Globalization.DurationDetail.Minutes">
            <summary>
            Display duration in hours, days, months and years
            </summary>
        </member>
        <member name="F:Fadd.Globalization.DurationDetail.Seconds">
            <summary>
            Display duration down to the second
            </summary>
        </member>
        <member name="T:Fadd.Globalization.IDateTimeHelper">
            <summary>
            Interface for all localized date/time helpers.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseDateTime(System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default DateTime.Parse method if date is in an unknown format.
            </summary>
            <param name="value">date/time string</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseDateTime(System.String,System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default DateTime.Parse method if date is in an unknown format.
            </summary>
            <param name="date">date string (may be null/empty).</param>
            <param name="time">time string (may be null/empty).</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseDate(System.String)">
            <summary>
            Tries to parse a date string.
            </summary>
            <param name="value">Can contain a complete date or parts of it (which parts depends on the country).</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseDate(System.String,System.Int32[],System.Int32)">
            <summary>
            Tries to parse a date string.
            </summary>
            <param name="value">Can contain a complete date or parts of it (which parts depends on the country).</param>
            <param name="values">array that parsed values are written to.</param>
            <param name="offset">where in array to start write values</param>
            <exception cref="T:System.FormatException">If the date format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseTime(System.String)">
            <summary>
            Tries to parse a time string.
            </summary>
            <param name="value">Can contain a complete time or parts of it (which parts depends on the country).</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ParseTime(System.String,System.Int32[],System.Int32)">
            <summary>
            Tries to parse a time string.
            </summary>
            <param name="value">Can contain a complete time or parts of it (which parts depends on the country).</param>
            <param name="values">array that will be filled. Must contain three slots.</param>
            <param name="offset">Where in the array to start write values</param>
            <exception cref="T:System.FormatException">If the time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ValidateDate(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate a date.
            </summary>
            <param name="year">year value</param>
            <param name="month">month value</param>
            <param name="day">day value</param>
            <param name="throwException">true if exceptions should be thrown on incorrect values.</param>
            <returns>true if specified values are a correct date; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.ValidateTime(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate 
            </summary>
            <param name="hour">hour</param>
            <param name="minute">minute</param>
            <param name="second">second</param>
            <param name="throwException">true if exceptions should be thrown on incorrect values.</param>
            <returns>true if specified values are a correct date; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.FormatDate(System.DateTime)">
            <summary>
            Format a date as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday", "On monday"</returns>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.FormatDateTime(System.DateTime)">
            <summary>
            Format a date/time as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday at 12:20pm", "On monday at 11:38am"</returns>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.GetDuration(System.DateTime,System.DateTime,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            <param name="measures">Number of time units to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.GetDuration(System.DateTime,System.DateTime)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.GetDuration(System.TimeSpan,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            /// <param name="measures">Number of time measures to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
            <remarks><see cref="F:Fadd.Globalization.DurationDetail.Months"/> cannot be used when using this method since counting of months
            requires both to and from datetime information, in such a case user <see cref="M:Fadd.Globalization.IDateTimeHelper.GetDuration(System.DateTime,System.DateTime,Fadd.Globalization.DurationDetail,System.Int32)"/></remarks>
        </member>
        <member name="M:Fadd.Globalization.IDateTimeHelper.GetDuration(System.TimeSpan)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
        </member>
        <member name="T:Fadd.Data.Transaction">
            <summary>
            Create a a transaction 
            </summary>
        </member>
        <member name="T:Fadd.Data.DataLayerImp">
            <summary>
            Base class for database handling
            </summary>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.#ctor(Fadd.Data.IConnectionHelper)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
            <param name="connectionHelper">The connection helper.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.#ctor(Fadd.Data.DataLayerImp)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
            <param name="dataLayerImp">Another implementation.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.#ctor(Fadd.Data.IConnectionHelper,Fadd.IGenericLogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
            <param name="helper">The connection helper.</param>
            <param name="logger">Logger interface.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Query``1(System.String,System.Object[])">
            <summary>
            Get a single object.
            </summary>
            <typeparam name="T">Type of object to fetch</typeparam>
            <param name="statement">complete SQL statement with class/properties instead of table/columns.</param>
            <param name="parameters">parameters used in the statement.</param>
            <returns>object if found; otherwise null</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.QueryCollection``1(System.String,System.Object[])">
            <summary>
            Gets a list of items.
            </summary>
            <param name="statement">Statements to get</param>
            <param name="parameters">parameters used in the statement.</param>
            <returns>A list of items.</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Execute``1(System.String,System.Object[])">
            <summary>
            Executes an statement in the database.
            </summary>
            <typeparam name="T">Type of object to fetch</typeparam>
            <param name="statement">complete SQL statement with class/properties instead of table/columns.</param>
            <param name="parameters">parameters used in the statement.</param>
            <returns>object if found; otherwise null</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Get``1(System.String,System.Object[])">
            <summary>
            Get a single object.
            </summary>
            <typeparam name="T">Type of object to fetch.</typeparam>
            <param name="conditions">Conditions (corresponds to statements in the WHERE clause).</param>
            <param name="parameters">Parameters used in the where clause.</param>
            <returns>object if found; otherwise null.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.GetById``1(System.Object)">
            <summary>
            Get a single object using its primary key
            </summary>
            <typeparam name="T">Type of object to fetch, must have a defined mapping.</typeparam>
            <param name="id">Primary key value</param>
            <returns>object if found; otherwise null.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Used to assign a property with a value
            </summary>
            <param name="instance">Object containing the property.</param>
            <param name="name">Name of the property.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Save(System.Object)">
            <summary>
            Save or update an object in the database (1. Checks if the PK is empty. 2. Checks if the object exists in the db).
            </summary>
            <param name="value">Value to create/update.</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Create(System.Object)">
            <summary>
            Create a new object in the database.
            </summary>
            <param name="value">Object to create.</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Update(System.Object)">
            <summary>
            Update an existing object.
            </summary>
            <param name="value">Object to update</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Update(System.Type,System.Object)">
            <summary>
            Update an existing object
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <exception cref="T:Fadd.Data.DataLayerException">If SQL query fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.ExistsById``1(System.Object)">
            <summary>
            Checks if an object exists by using it's primary key.
            </summary>
            <typeparam name="T">Type of object to check</typeparam>
            <param name="id">Primary key</param>
            <returns>true if object was found; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Exists(System.Object)">
            <summary>
            Checks if an object exists by providing it.
            </summary>
            <param name="model">object to check</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Exists``1(System.String,System.Object[])">
            <summary>
            Checks if an object exists in the database
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <param name="conditions">Conditions.</param>
            <param name="parameters">parameters used in the conditions.</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Exists(Fadd.Data.CompiledStatement,System.Collections.Generic.IList{System.Object})">
            <exception cref="T:Fadd.Data.DataLayerException"><c>DataLayerException</c>.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Execute(Fadd.Data.CompiledStatement,System.Collections.Generic.IList{System.Object})">
            <exception cref="T:Fadd.Data.DataLayerException"><c>DataLayerException</c>.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Execute(System.String,System.Collections.Generic.IList{System.Object})">
            <exception cref="T:Fadd.Data.DataLayerException"><c>DataLayerException</c>.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.CreateCommand(System.Data.IDbConnection,Fadd.Data.CompiledStatement,System.Collections.Generic.IList{System.Object})">
            <summary>
            Creates a complete database command with the help of the compiled statement.
            </summary>
            <param name="connection">Used to create the command</param>
            <param name="statement">Statement to execute</param>
            <param name="parameters">parameters used in the statement</param>
            <returns>A filled command</returns>
            <exception cref="T:System.ArgumentException">Parameter count doesn't match argument count in the statement.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.CreateCommand(System.Data.IDbConnection,System.String,System.Collections.Generic.IList{System.Object})">
            <summary>
            Creates a complete database command with the help of the compiled statement.
            </summary>
            <param name="connection">Used to create the command</param>
            <param name="sql">Custom sql to execute</param>
            <param name="parameters">parameters used in the statement</param>
            <returns>A filled command</returns>
            <exception cref="T:System.ArgumentException">Parameter count doesn't match argument count in the statement.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Find``1(System.String,System.Object[])">
            <summary>
            Retrieves a collection of items.
            </summary>
            <typeparam name="T">Type of item to get.</typeparam>
            <param name="conditions">Conditions to limit.</param>
            <param name="parameters">Parameters used in the condition.</param>
            <returns>A list of objects; or an empty list</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Find``1">
            <summary>
            Retrieves all items of a certain type.
            </summary>
            <typeparam name="T">Type of item to get.</typeparam>
            <returns>A list of objects; or an empty list</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.FindBySQL``1(System.String,System.Object[])">
            <summary>
            Execute a custom SQL query (Object SQL can not be used yet).
            </summary>
            <typeparam name="T">type of items to get.</typeparam>
            <param name="query">SQL query.</param>
            <param name="parameters">Parameters used in the query.</param>
            <returns>A list of elements.</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Find``1(Fadd.Data.Statement)">
            <summary>
            Gets all items defined by the <see cref="T:Fadd.Data.Statement"/>.
            </summary>
            <typeparam name="T">type of items to get.</typeparam>
            <param name="statement">Statement specifying which elements to get.</param>
            <returns>A list of elements.</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.RemoveById``1(System.Object)">
            <summary>
            Removes an object by using it's id property.
            </summary>
            <typeparam name="T">Type of object to remove.</typeparam>
            <param name="id">Primary key value</param>
            <exception cref="T:Fadd.Data.Mappings.MappingException">RemoveById requires exactly one primary key.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Remove``1(System.String,System.Object[])">
            <summary>
            Removes an object by using it's id property.
            </summary>
            <typeparam name="T">Type of object to remove.</typeparam>
            <exception cref="T:Fadd.Data.DataLayerException">Data layer failed.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Count``1(System.String,System.Object[])">
            <summary>
            Count number of items.
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <param name="conditions">Conditions.</param>
            <param name="arguments">Arguments used in the conditions.</param>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.Count``1">
            <summary>
            Count number of items.
            </summary>
            <typeparam name="T">Type of object to check.</typeparam>
            <returns>true if object is stored in the database; otherwise false.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If the class/table mapping is incorrect.</exception>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.CountBySQL(System.String)">
            <summary>
            Counts by SQL. Write the whole statement yourself.
            </summary>
            <param name="sql">The statement.</param>
            <returns>Number of returned rows</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If data layer fails.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.CreateConnection">
            <summary>
            Creates a connection, we use this method instead of the one in
            the connection helper to be able to use transactions (with a single connection).
            </summary>
            <returns>A database connection.</returns>
        </member>
        <member name="M:Fadd.Data.DataLayerImp.CreateCommand(System.Data.IDbConnection)">
            <summary>
            Create a command.
            </summary>
            <param name="connection">Connection used to create the command</param>
            <returns>A <see cref="T:System.Data.IDbCommand"/></returns>
        </member>
        <member name="P:Fadd.Data.DataLayerImp.Logger">
            <summary>
            Gets or sets logger instance.
            </summary>
        </member>
        <member name="P:Fadd.Data.DataLayerImp.IsTransaction">
            <summary>
            Determines if we are a transaction.
            </summary>
        </member>
        <member name="P:Fadd.Data.DataLayerImp.MappingProviders">
            <summary>
            Gets class that takes care of all providers.
            </summary>
        </member>
        <member name="P:Fadd.Data.DataLayerImp.ConnectionHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fadd.Data.Transaction.#ctor(Fadd.Data.DataLayerImp,System.Data.IsolationLevel)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Data.Transaction.#ctor(Fadd.Data.DataLayerImp)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Data.Transaction.Cancel">
            <summary>
            Cancels all changes.
            </summary>
        </member>
        <member name="M:Fadd.Data.Transaction.Commit">
            <summary>
            Makes all changes permanent in the database.
            </summary>
        </member>
        <member name="M:Fadd.Data.Transaction.CreateConnection">
            <summary>
            We are not creating a connection, but returning the one used
            in the transaction.
            </summary>
            <returns>A database connection.</returns>
        </member>
        <member name="M:Fadd.Data.Transaction.CreateCommand(System.Data.IDbConnection)">
            <summary>
            Creates the command.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fadd.Data.Transaction.CreateTransaction(System.Data.IsolationLevel)">
            <summary>
            Creates a new transaction.
            </summary>
            <param name="level">On of the <see cref="T:System.Data.IsolationLevel"/>s.</param>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="M:Fadd.Data.Transaction.CreateTransaction">
            <summary>
            Creates a new transaction.
            </summary>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="M:Fadd.Data.Transaction.Dispose">
            <summary>
                                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Fadd.Data.Transaction.IsTransaction">
            <summary>
            Determines if we are a transaction.
            </summary>
        </member>
        <member name="E:Fadd.Data.Transaction.Committing">
            <summary>
            Transaction is about to be committed.
            </summary>
        </member>
        <member name="E:Fadd.Data.Transaction.Committed">
            <summary>
            Transaction have been committed.
            </summary>
        </member>
        <member name="E:Fadd.Data.Transaction.Canceling">
            <summary>
            Transaction is about to be canceled.
            </summary>
        </member>
        <member name="E:Fadd.Data.Transaction.Canceled">
            <summary>
            Transaction have been canceled.
            </summary>
        </member>
        <member name="M:Fadd.Data.TransactionWrapper.Commit">
            <summary>
            Don't do anything since someone have already created a transaction.
            Let the initial creator commit.
            </summary>
        </member>
        <member name="M:Fadd.Data.TransactionWrapper.Cancel">
            <summary>
            Don't do anything since someone have already created a transaction.
            Let the initial creator commit or rollback.
            </summary>
            <exception cref="T:Fadd.Data.DataLayerException">To abort the transaction.</exception>
        </member>
        <member name="T:Fadd.Data.StatementCompiler">
            <summary>
            Compiles and caches SQL statements to speed up processing.
            </summary>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.#ctor(Fadd.Data.Mappings.Provider,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.StatementCompiler"/> class.
            </summary>
            <param name="providers">The providers.</param>
            <param name="cacheStatements">if set to <c>true</c> [cache statements].</param>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.Compile(System.String)">
            <summary>
            Compiles an object SQL statement
            </summary>
            <param name="objectSql"></param>
            <returns></returns>
            <exception cref="T:System.FormatException"><c>FormatException</c>.</exception>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If mapping could not be found.</exception>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.ScanProperties(Fadd.Parser.Token,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Recursive scanning after properties.
            </summary>
            <param name="token"></param>
            <param name="conditions"></param>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.GetOrCreate(System.String,System.String,System.Object[])">
            <summary>
            Compile an Object SQL statement and return the corresponding SQL statement.
            </summary>
            <param name="key">Key used to identify this statement (if caching is turned on)</param>
            <param name="objectSql">SQL statement with classes/properties instead of tables/columns.</param>
            <param name="parameters"></param>
            <returns></returns>
            <exception cref="T:System.FormatException">If SQL is malformed.</exception>
            <exception cref="T:Fadd.Data.Mappings.MappingException">Failed to find mapping file.</exception>
            <exception cref="T:System.ArgumentNullException"><c>key</c> or <c>objectSql</c> is null.</exception>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.ParseToken(Fadd.Parser.Token,Fadd.Data.Mappings.IMapping)">
            <summary>
            Goes through a token and all it's children to convert properties/classes to columns/tables.
            </summary>
            <param name="token">Token to process</param>
            <param name="mapping">Mapping file used during conversion.</param>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.Get(System.String)">
            <summary>
            Get a previously compiled statement.
            </summary>
            <param name="key">Key used when storing the statement.</param>
            <returns>Compiled statement if found; otherwise null.</returns>
            <exception cref="T:System.InvalidOperationException">If statements are not cached.</exception>
        </member>
        <member name="M:Fadd.Data.StatementCompiler.Create(System.String,System.String)">
            <summary>
            Create a new compiled statement.
            </summary>
            <param name="key">Key used to store statement for future use.</param>
            <param name="objectSql">ObjectSQL that should be compiled into plain sql.</param>
            <returns>Compiled statement.</returns>
        </member>
        <member name="T:Fadd.ValueChecker">
            <summary>
            Checks whether a column is empty or not.
            </summary>
        </member>
        <member name="M:Fadd.ValueChecker.AddChecker(System.Type,Fadd.IValueCheck)">
            <summary>
            Add a class that determines if a certain type is empty or not.
            </summary>
            <param name="type">Type to check</param>
            <param name="check">Object checking values.</param>
            <exception cref="T:System.InvalidOperationException">Type have already been mapped.</exception>
        </member>
        <member name="M:Fadd.ValueChecker.IsEmpty(System.Object)">
            <summary>
            Determines if an object is empty.
            </summary>
            <param name="value">object to check</param>
            <returns>true if empty; otherwise false.</returns>
        </member>
        <member name="T:Fadd.IValueCheck">
            <summary>
            Implementation checking if a value is empty.
            </summary>
        </member>
        <member name="M:Fadd.IValueCheck.IsEmpty(System.Object)">
            <summary>
            Determines if an object is empty.
            </summary>
            <param name="value">object to check</param>
            <returns>true if empty; otherwise false.</returns>
        </member>
        <member name="T:Fadd.Validation.ValidateMinAttribute">
            <summary>
            Specifies a max length.
            </summary>
            <remarks>
            On a string it specified maximum number of letters, while on int it specifies the max number.
            </remarks>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>AlphaNumeric</term>
                    <description>'{0}' may only contain alpha numeric letters.</description>
                </item>
            </list>
            </para>
        </member>
        <member name="M:Fadd.Validation.ValidateMinAttribute.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateMaxAttribute"/> class.
            </summary>
            <param name="value">minimum length. should match the type being validated, with the exception of string
            where the type should be int.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateMinAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ValidateMinAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateMinAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="P:Fadd.Validation.ValidateMinAttribute.Value">
            <summary>
            Minimum length
            </summary>
        </member>
        <member name="T:Fadd.Validation.MissingPropertyException">
            <summary>
            thrown when the specified property is not found in the specified class.
            </summary>
        </member>
        <member name="M:Fadd.Validation.MissingPropertyException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.MissingPropertyException"/> class.
            </summary>
            <param name="className">Name of the class.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:Fadd.Validation.ValidateMaxAttribute">
            <summary>
            Specifies a max length.
            </summary>
            <remarks>
            On a string it specified maximum number of letters, while on int it specifies the max number.
            </remarks>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>Max</term>
                    <description>'{0}' must be less or equal to {1}.</description>
                </item>
                <item>
                    <term>MaxString</term>
                    <description>'{0}' must be contain {1} or less characters.</description>
                </item>
            </list>
            </para>
        </member>
        <member name="M:Fadd.Validation.ValidateMaxAttribute.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateMaxAttribute"/> class.
            </summary>
            <param name="max">max length. should match the type being validated, with the exception of string
            where the type should be int.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateMaxAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">If the specified object is not supported.</exception>
            <remarks>
            Supports basetypes and all types that implements IComparable (passing an int)
            </remarks>
        </member>
        <member name="M:Fadd.Validation.ValidateMaxAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateMaxAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="P:Fadd.Validation.ValidateMaxAttribute.Max">
            <summary>
            Max length
            </summary>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyReceiver">
            <summary>
            This class is used to receive and handle 
            </summary>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyReceiver.#ctor(Fadd.Commands.ICommandDispatcher)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.ObjectProxyReceiver"/> class.
            </summary>
            <param name="dispatcher">Dispatcher that the proxy commands will arrive on.</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyReceiver.OnProxyRequest(System.Object,Fadd.Commands.CommandEventArgs)">
            <summary>
            Called when a proxy command arrives.
            </summary>
            <param name="source"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="E:Fadd.Commands.ObjectProxyReceiver.InstanceRequested">
            <summary>
            Event used to retrieve an instace for a specific type.
            </summary>
            <remarks>
            The instance is used to invoke the requested method.
            </remarks>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyReceiver.Instances">
            <summary>
            Type to instance mappings
            </summary>
            <remarks>
            Maps all types to object instances that are used to invoke the method calls.
            </remarks>
        </member>
        <member name="T:Fadd.Commands.InstanceRequestedEventArgs">
            <summary>
            Arguments for <see cref="T:Fadd.Commands.InstanceRequestedHandler"/>
            </summary>
        </member>
        <member name="M:Fadd.Commands.InstanceRequestedEventArgs.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.InstanceRequestedEventArgs"/> class.
            </summary>
            <param name="type">Type of instance wanted.</param>
        </member>
        <member name="P:Fadd.Commands.InstanceRequestedEventArgs.Type">
            <summary>
            Type of instance wanted.
            </summary>
        </member>
        <member name="P:Fadd.Commands.InstanceRequestedEventArgs.Instance">
            <summary>
            Instance that will be used to invoke method.
            </summary>
        </member>
        <member name="T:Fadd.Commands.InstanceRequestedHandler">
            <summary>
            Delegate used by <see cref="T:Fadd.Commands.InstanceRequestedHandler"/> to find instance to invoke on.
            </summary>
            <param name="source"><see cref="T:Fadd.Commands.InstanceRequestedHandler"/></param>
            <param name="args">Arguments</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Select">
            <summary>
            SELECT clause
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Select.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>"SELECT "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Select.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty">
            <summary>
            Name of the property to sort by, and if the sort is ascending/descending.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty"/> class.
            </summary>
            <param name="name">Name of the property.</param>
            <param name="ascending">if set to <c>true</c> sort is ascending.</param>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>Order by property</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.Property">
            <summary>
            Property that the order by is for
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.Ascending">
            <summary>
            Ascending or Descending sort
            </summary>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.OrderByProperty.Name">
            <summary>
            Name of the property.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.StopContext">
            <summary>
            Parse ), which is end of sub context / nesting.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StopContext.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StopContext.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.IsNotNullToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.IsNotNullToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.StopContext">
            <summary>
            Parse ), which is end of subcontext / nesting.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.StopContext.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.StopContext.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.StartContext">
            <summary>
            Parse (, which is start of one level nesting.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.StartContext.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.StartContext.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Data.Mappings.ILoader">
            <summary>
            Provides a mapping between properties and columns in a table.
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.ILoader.GetMapping(System.String)">
            <summary>
            Get a mapping between a table and a class.
            </summary>
            <param name="className">Name of class, may not be full name</param>
            <returns><see cref="T:Fadd.Data.Mappings.IMapping"/> if found; otherwise null.</returns>
        </member>
        <member name="T:Fadd.Plugins.PluginLoadedHandlerEventArgs`1">
            <summary>
            Arguments for <see cref="T:Fadd.Plugins.PluginLoadedHandler`1"/>
            </summary>
            <typeparam name="T">Implementation of IPlugin</typeparam>
        </member>
        <member name="M:Fadd.Plugins.PluginLoadedHandlerEventArgs`1.#ctor(`0,System.Reflection.Assembly,Fadd.Plugins.PluginTypeInfo)">
            <summary>
            Called when a plugin have been loaded.
            </summary>
            <param name="plugin">Plugin being loaded.</param>
            <param name="assembly">Assembly that the plugin exist in.</param>
            <param name="typeInfo">information about the plugin</param>
            <remarks>Plugin have not been started yet.</remarks>
        </member>
        <member name="P:Fadd.Plugins.PluginLoadedHandlerEventArgs`1.Plugin">
            <summary>
            Plugin being loaded
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginLoadedHandlerEventArgs`1.Assembly">
            <summary>
            Assembly that the plugin exist in
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginLoadedHandlerEventArgs`1.TypeInfo">
            <summary>
            information about the plugin
            </summary>
        </member>
        <member name="T:Fadd.Plugins.PluginLoadedHandler`1">
             <summary>
             Invoked when a plugin have been loaded into the system.
             </summary>
            <param name="source">PluginManager that loaded the plugin.</param>
            <param name="args">Plugin information.</param>
        </member>
        <member name="T:Fadd.Commands.FilterHandler">
            <summary>
            This delegate is invoked when a command is about to behing invoked or added to the dispatcher.
            <para>
            Throw <see cref="T:System.InvalidOperationException"/> if Type may not be handled/invoked.
            </para>
            </summary>
            <param name="source">dispatcher that is being used.</param>
            <param name="args">arguments with info</param>
        </member>
        <member name="T:Fadd.Commands.FilterEventArgs">
            <summary>
            Arguments for <see cref="T:Fadd.Commands.FilterHandler"/>.
            </summary>
        </member>
        <member name="M:Fadd.Commands.FilterEventArgs.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.FilterEventArgs"/> class.
            </summary>
            <param name="type">Type of command (if Invoke is called) or Type to handle (if Add is called).</param>
        </member>
        <member name="P:Fadd.Commands.FilterEventArgs.Type">
            <summary>
            Type of command (if Invoke is called) or Type to handle (if Add is called).
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.CommandServer">
            <summary>
            Receives commands from the client and invoked them in the server dispatcher.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.CommandServer.#ctor(Fadd.Commands.CommandManager)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.CommandServer"/> class.
            </summary>
            <param name="mgr">Manager that the incoming commands are invoked in.</param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandServer.Start(System.Net.IPAddress,System.Int32)">
            <summary>
            Starts the server.
            </summary>
            <param name="address">IP address that we accept incoming connections on.</param>
            <param name="port">Port that the server accepts new connections on.</param>
        </member>
        <member name="M:Fadd.Commands.Net.CommandServer.Stop">
            <summary>
            Stops the server.
            </summary>
        </member>
        <member name="T:Fadd.Parser.Tokenizer">
            <summary>
            Converts a string to a token tree.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Parse(System.IO.Stream,Fadd.Parser.ParseTree)">
            <summary>
            Parses the specified stream.
            </summary>
            <param name="stream">Stream with text content.</param>
            <param name="tree">Tree that will be filled with tokens.</param>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Parse(System.String,Fadd.Parser.ParseTree)">
            <summary>
            Parses the specified text.
            </summary>
            <param name="text">Text to parse.</param>
            <param name="tree">Tree that will be filled with tokens.</param>
            <exception cref="T:System.NotSupportedException">When we find unsupported tokens.</exception>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.GetPrototype(System.Type)">
            <summary>
            Prototypes are used to 
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.LookAhead(System.Int32)">
            <summary>
            Get a string for the next <paramref name="count"/> chars.
            </summary>
            <param name="count">Number of chars to peek.</param>
            <returns>A string with <paramref name="count"/> characters.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.LookAhead(System.Int32,System.String)">
            <summary>
            Get a string for the next <paramref name="count"/> chars.
            </summary>
            <param name="count">Number of chars to peek</param>
            <param name="ignoreCharacters">Ignore these characters before starting to count</param>
            <returns>A string with <paramref name="count"/> characters.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Previous">
            <summary>
            Get previous character
            </summary>
            <returns>A <see cref="T:System.Char"/></returns>
            <remarks>Will not change the current position</remarks>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Previous(System.Int32)">
            <summary>
            Scroll back <paramref name="steps"/> and get that char.
            </summary>
            <param name="steps">Number of chars back</param>
            <returns>A <see cref="T:System.Char"/></returns>
            <remarks>Will not change the current position</remarks>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Peek(System.Int32)">
            <summary>
            Peek forward on a char
            </summary>
            <param name="steps">Which char index (from current position) to get.</param>
            <returns>A <see cref="T:System.Char"/>.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Peek(System.String,System.Int32)">
            <summary>
            Peek forward on a char
            </summary>
            <param name="ignoreChars">Ignore these characters before string to peek</param>
            <param name="steps">Which char index (from current position) to get.</param>
            <returns>A <see cref="T:System.Char"/>.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.PeekIgnore(System.String)">
            <summary>
            Get next position that do not contain the specified chars.
            </summary>
            <param name="ignoreChars"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Peek">
            <summary>
            Peek on the next character
            </summary>
            <returns>The next character</returns>
            <exception cref="T:System.InvalidOperationException">If trying to peek beyond last character in the string.</exception>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Peek(System.Boolean)">
            <summary>
            Peek forward
            </summary>
            <param name="throwException">true if extensions should be thrown</param>
            <returns><see cref="F:System.Char.MinValue"/> if no extensions should be thrown and we are peeking beyond end of text.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Peek(System.String)">
            <summary>
            Peek at the next character.
            </summary>
            <param name="ignoreChars">Characters that are ignored (not counted).</param>
            <returns>the next character, or <see cref="F:System.Char.MinValue"/> if no more characters exist.</returns>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Read(System.Int32)">
            <summary>
            Read X number of characters
            </summary>
            <param name="length">number of characters to read</param>
            <returns>A string</returns>
            <remarks>Moves current position forward.</remarks>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Read">
            <summary>
            Read a character
            </summary>
            <returns>A char</returns>
            <remarks>Moves current position forward.</remarks>
        </member>
        <member name="M:Fadd.Parser.Tokenizer.Ignore(System.String)">
            <summary>
            Ignore all specified chars
            </summary>
            <param name="ignoreCharacters">chars to ignore</param>
            <returns>true if end of text is not hit.</returns>
            <remarks>Moves current position forward.</remarks>
        </member>
        <member name="P:Fadd.Parser.Tokenizer.CurrentPosition">
            <summary>
            Returns index of current position as a string.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Tokenizer.Prototypes">
            <summary>
            All prototype tokens.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Tokenizer.EOF">
            <summary>
            We are at end of text
            </summary>
        </member>
        <member name="P:Fadd.Parser.Tokenizer.PeekEOF">
            <summary>
            Next character is the last one.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.EndContext">
            <summary>
            End of context.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.EndContext.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>(</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.EndContext.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.In">
            <summary>
            A IN clause.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.In.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Data.Mappings.Provider">
            <summary>
            Provides mappings between tables and classes.
            </summary>
            <remarks>
            <para>
            Mappings are loaded using one or more different loaders. In this way
            you can provide your own special way of loading mappings, or use one of
            our built in loaders such as mirror loader and XmlLoader.
            </para>
            <para>
            You can also add mappings manually by using the <see cref="M:Fadd.Data.Mappings.Provider.AddMapping(Fadd.Data.Mappings.IMapping)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:Fadd.Data.Mappings.Provider.AddMapping(Fadd.Data.Mappings.IMapping)">
            <summary>
            Add a mapping.
            </summary>
            <param name="mapping">Mapping file.</param>
        </member>
        <member name="M:Fadd.Data.Mappings.Provider.GetMapping(System.String)">
            <summary>
            Get a mapping file.
            </summary>
            <remarks>
            Will go through all different loaders until of of them return a mapping.
            All found mappings are cached.
            </remarks>
            <param name="className">class to fetch a mapping for.</param>
            <returns><see cref="T:Fadd.Data.Mappings.IMapping"/> if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Data.Mappings.Provider.Add(Fadd.Data.Mappings.ILoader)">
            <summary>
            Add a <see cref="T:Fadd.Data.Mappings.ILoader"/>.
            </summary>
            <param name="loader"></param>
        </member>
        <member name="T:Fadd.Validator">
            <summary>
            General usage validator class.
            </summary>
            <remarks>
            <para>Check all FieldXXXXX constants to see what you need to translate.</para>
            </remarks>
        </member>
        <member name="F:Fadd.Validator.FieldDouble">
            <summary>
            '{0}' is not a double.
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldCurrency">
            <summary>
            '{0}' is not a valid amount.
            </summary>
            <remarks>Uses Double validation internally</remarks>
        </member>
        <member name="F:Fadd.Validator.FieldNumber">
            <summary>
            '{0}' is not a number.
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldBoolean">
            <summary>
            '{0}' must be {1} or {2}.
            </summary>
            <seealso cref="M:Fadd.Validator.Boolean(System.String,System.String,System.Boolean)"/>
            <see cref="F:Fadd.Validator.FieldValueFalse"/>
            <see cref="F:Fadd.Validator.FieldValueTrue"/>
        </member>
        <member name="F:Fadd.Validator.FieldEmail">
            <summary>
            '{0}' is not a valid email address.
            </summary>
            <seealso cref="M:Fadd.Validator.Email(System.String,System.String,System.Boolean)"/>
            <seealso cref="F:Fadd.Validator.EmailRegEx"/>
        </member>
        <member name="F:Fadd.Validator.FieldLettersOrDigits">
            <summary>
            '{0}' can only contain letters or digits.
            </summary>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator.FieldLettersOrDigitsExtra">
            <summary>
            '{0}' can only contain letters, digits and the following characters: '{1}'.
            </summary>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean,System.String)"/>
        </member>
        <member name="F:Fadd.Validator.FieldPassword">
            <summary>
            '{0}' can only contain letters, digits and any of the following characters: {1}
            </summary>
            <seealso cref="F:Fadd.Validator.PasswordChars"/>
            <seealso cref="M:Fadd.Validator.Password(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator.FieldRequired">
            <summary>
            '{0}' is required.
            </summary>
            <seealso cref="M:Fadd.Validator.Required(System.String,System.String)"/>
        </member>
        <member name="F:Fadd.Validator.FieldValueFalse">
            <summary>
            Used to check if a field is false.
            </summary>
            <seealso cref="M:Fadd.Validator.Boolean(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator.FieldValueTrue">
            <summary>
            Text: True
            </summary>
            <seealso cref="M:Fadd.Validator.Boolean(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator.FieldAlphaNumeric">
            <summary>
            '{0}' may only contain writable characters.
            </summary>
            <remarks>ascii 32-126, 128-167, 224-238.</remarks>
        </member>
        <member name="F:Fadd.Validator.FieldHex">
            <summary>
            Name of the string to display when testing hex fail
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldLetters">
            <summary>
            Name of string to display when testing letters fail
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldLettersSpecial">
            <summary>
            Name of string to display when testing letters fail
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldDigits">
            <summary>
            '{0}' may only contain digits
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldDigitsExtra">
            <summary>
            '{0}' may only contain digits and the following characters: '{1}'
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldBetween">
            <summary>
            '{0}' must be between '{1}' and '{2}'
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldMin">
            <summary>
            '{0}' must be '{1}' or more
            </summary>
        </member>
        <member name="F:Fadd.Validator.FieldMax">
            <summary>
            '{0}' must be '{1}' or less
            </summary>
        </member>
        <member name="F:Fadd.Validator.ValidChars">
            <summary>
            Characters that are valid in alphanumeric fields.
            </summary>
        </member>
        <member name="F:Fadd.Validator.SqlSafeChars">
            <summary>
            SQL Safe characters (not including '")
            </summary>
        </member>
        <member name="F:Fadd.Validator.Space">
            <summary>
            Space character.
            </summary>
        </member>
        <member name="F:Fadd.Validator.EmailRegEx">
            <summary>
            Regex used to validate emails.
            </summary>
            <seealso cref="M:Fadd.Validator.Email(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator.Language">
            <summary>
            Language manager used if no one else have been specified.
            </summary>
        </member>
        <member name="F:Fadd.Validator.PasswordChars">
            <summary>
            Extra characters that are allowed in passwords.
            </summary>
            <seealso cref="M:Fadd.Validator.Password(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="F:Fadd.Validator._errors">
            <summary>
            A list with all errors found.
            </summary>
        </member>
        <member name="F:Fadd.Validator._modelLang">
            <summary>
            Language translation for all "name" parameters.
            </summary>
        </member>
        <member name="F:Fadd.Validator._validatorLang">
            <summary>
            Language for the validator (i.e. "Field {0} is required.")
            </summary>
        </member>
        <member name="M:Fadd.Validator.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Create a new validator.
            </summary>
            <param name="errors">collection to be filled with errors</param>
        </member>
        <member name="M:Fadd.Validator.#ctor(System.Collections.Specialized.NameValueCollection,Fadd.Globalization.ILanguageNode)">
            <summary>
            Create a new validator.
            </summary>
            <param name="errors">collection to be filled with errors</param>
            <param name="modelLanguage">language translation for all "name" parameters</param>
        </member>
        <member name="M:Fadd.Validator.#ctor(Fadd.Globalization.ILanguageNode)">
            <summary>
            Create a new validator.
            </summary>
            <param name="modelLanguage">language translation for all "name" parameters</param>
        </member>
        <member name="M:Fadd.Validator.#ctor">
            <summary>
            Create a new validator
            </summary>
        </member>
        <member name="M:Fadd.Validator.Max(System.String,System.Int32,System.Object,System.Boolean)">
            <summary>
            Check whether the specified field is within the limit.
            </summary>
            <param name="name">field name.</param>
            <param name="max">max value.</param>
            <param name="value">value to check.</param>
            <param name="required">if set to <c>true</c> the field is required.</param>
            <returns>true if the field is within the limit</returns>
            <remarks>
            number are check to be less or equal to max. Strings are checked on the number of characters.
            </remarks>
        </member>
        <member name="M:Fadd.Validator.Min(System.String,System.Int32,System.Object,System.Boolean)">
            <summary>
            Check whether the specified field is within the limit.
            </summary>
            <param name="name">field name.</param>
            <param name="min">min value.</param>
            <param name="value">value to check.</param>
            <param name="required">if set to <c>true</c> the field is required.</param>
            <returns>true if the field is within the limit</returns>
            <remarks>
            number are check to be less or equal to min. Strings are checked on the number of characters.
            </remarks>
        </member>
        <member name="M:Fadd.Validator.Between(System.String,System.Int32,System.Int32,System.Object,System.Boolean)">
            <summary>
            Check whether the specified field is within the limit.
            </summary>
            <param name="name">field name.</param>
            <param name="min">min value.</param>
            <param name="max">max value</param>
            <param name="value">value to check.</param>
            <param name="required">if set to <c>true</c> the field is required.</param>
            <returns>true if the field is within the limit</returns>
            <remarks>
            number are check to be less or equal to min. Strings are checked on the number of characters.
            </remarks>
        </member>
        <member name="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean)">
            <summary>
            Validate that a string only contains letters or digits.
            </summary>
            <param name="name">Form parameter name.</param>
            <param name="value">value to validate</param>
            <param name="required">may not be null or empty if true.</param>
            <returns>value if valid; otherwise string.Empty</returns>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean,System.String)"/>
        </member>
        <member name="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Validate that a string only contains letters, digits or the specified characters
            </summary>
            <param name="name">Form parameter name.</param>
            <param name="value">value to validate</param>
            <param name="required">may not be null or empty if true.</param>
            <param name="extraCharacters">any other allowed characters.</param>
            <returns>value if valid; otherwise string.Empty</returns>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Fadd.Validator.Password(System.String,System.String,System.Boolean)">
            <summary>
            Validate that a string only contains letters or digits or any of the <see cref="F:Fadd.Validator.PasswordChars"/>.
            </summary>
            <param name="name">Form parameter name.</param>
            <param name="value">value to validate</param>
            <param name="required">field may not be empty or null if true</param>
            <returns>vaue if valid; otherwise string.Empty</returns>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Fadd.Validator.Required(System.String,System.String)">
            <summary>
            Check's weather a parameter is null or not.
            </summary>
            <param name="name">Parameter in form</param>
            <returns>true if value is not null/empty; otherwise false.</returns>
            <param name="value">value that cannot be null or empty.</param>
        </member>
        <member name="M:Fadd.Validator.String(System.String,System.String,System.Boolean)">
            <summary>
            Validate a string parameter in the form
            </summary>
            <param name="name">Form parameter name.</param>
            <param name="value">value to validate as string.</param>
            <param name="required">field may not be empty or null if true.</param>
            <returns>vaue if valid; otherwise string.Empty</returns>
            <seealso cref="M:Fadd.Validator.LettersOrDigits(System.String,System.String,System.Boolean)"/>
            <seealso cref="M:Fadd.Validator.AlphaNumeric(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Fadd.Validator.AddDefaultPhrases">
            <summary>
            add default language phrases (only english)
            </summary>
        </member>
        <member name="M:Fadd.Validator.Contains(System.String,System.Char)">
            <summary>
            Checks wether a string contains a specific character.
            </summary>
            <param name="s">source</param>
            <param name="ch">character to find.</param>
            <returns>true if found; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Validator.Format(System.String,System.String)">
            <summary>
            format an error message
            </summary>
            <param name="format">string containing the formatting</param>
            <param name="fieldName">name of the field that the error ocurred for.</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Fadd.Validator.Format(System.String,System.String,System.String)">
            <summary>
            format an error message
            </summary>
            <param name="format">string containing the formatting</param>
            <param name="fieldName">name of the field that the error ocurred for.</param>
            <param name="extra">extra value in the formatting</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Fadd.Validator.Format(System.String,System.String,System.String,System.String)">
            <summary>
            format an error message
            </summary>
            <param name="format">string containing the formatting</param>
            <param name="fieldName">name of the field that the error ocurred for.</param>
            <param name="extra">extra value in the formatting</param>
            <param name="extra2">third parameter in the formatting</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Fadd.Validator.Char(System.String,System.String,System.Boolean)">
            <summary>
            Check whether the specified value is an character.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is an int; char.MinValue if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Char(System.String,System.String)">
            <summary>
            Check whether the specified value is an character.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <returns>value if parameter is an int; char.MinValue if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Integer(System.String,System.String,System.Boolean)">
            <summary>
            Check whether the specified value is an integer.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is an int; 0 if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Double(System.String,System.String,System.Boolean)">
            <summary>
            Check whether the specified value is a double.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is a double; 0 if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Currency(System.String,System.String,System.Boolean)">
            <summary>
            Check whether the specified value is a currency amount.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is a currency amount; 0 if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Double(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Check whether the specified value is a double.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter is a double; 0 if not.</returns>
            <param name="formatString">error string</param>
        </member>
        <member name="M:Fadd.Validator.AlphaNumeric(System.String,System.String,System.Boolean)">
            <summary>
            Check whether the specified value is an integer.
            </summary>
            <param name="name">Name of the parameter</param>
            <param name="value">Parameter value to validate</param>
            <param name="required">Paramater is required (adds an error if it's not specified)</param>
            <returns>value if parameter contains valid characters; string.Empty if not.</returns>
            <remarks>ascii 32-126, 128-167, 224-238.</remarks>
        </member>
        <member name="M:Fadd.Validator.Digits(System.String,System.String,System.Boolean)">
            <summary>
            Check if a value is digits only
            </summary>
            <param name="name">Field name.</param>
            <param name="value">value to validate</param>
            <param name="required">true if field is required (may not be empty)</param>
            <returns>string if validated, otherwise string.Empty</returns>
        </member>
        <member name="M:Fadd.Validator.Digits(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Check if a value is digits only
            </summary>
            <param name="name">Field name.</param>
            <param name="value">value to validate</param>
            <param name="extraAllowedCharacters">extra characters that is allowed.</param>
            <param name="required">true if field is required (may not be empty)</param>
            <returns>string if validated, otherwise string.Empty</returns>
        </member>
        <member name="M:Fadd.Validator.Letters(System.String,System.String,System.Boolean)">
            <summary>
            Validates a string to consist of letters.
            </summary>
            <param name="name">field name</param>
            <param name="value">value to validate</param>
            <param name="required">field is required</param>
            <returns>string if valid, string.Empty if not.</returns>
        </member>
        <member name="M:Fadd.Validator.Letters(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Validates a string to consist of letters plus specified characters.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="value">The value to validate</param>
            <param name="required">If the value is required</param>
            <param name="extraAllowedCharacters">A string consisting of extra allowed characters</param>
            <returns>The validated string or string.Empty if validation failed</returns>
        </member>
        <member name="M:Fadd.Validator.Hex(System.String,System.String,System.Boolean)">
            <summary>
            Validates a string to be in trimmed hex letters
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="value">The value to test</param>
            <param name="required">If the parameter is required</param>
            <returns>The value or string.Empty if validation failed</returns>
        </member>
        <member name="M:Fadd.Validator.Email(System.String,System.String,System.Boolean)">
            <summary>
            validates email address using a regexp.
            </summary>
            <param name="name">field name</param>
            <param name="value">value to validate</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>value if validation is ok; otherwise string.Empty.</returns>
        </member>
        <member name="M:Fadd.Validator.Between(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            validates that a certain number is within the specified interval
            </summary>
            <param name="name">field name</param>
            <param name="value">value to validate</param>
            <param name="max">The maximum value that value is allowed to be</param>
            <param name="min">The minimum value that value is allowed to be</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>value if validation is ok; otherwise 0.</returns>
        </member>
        <member name="M:Fadd.Validator.Between(System.String,System.String,System.Double,System.Double,System.Boolean)">
            <summary>
            validates that a certain number is within the specified interval
            </summary>
            <param name="name">field name</param>
            <param name="value">value to validate</param>
            <param name="max">The maximum value that value is allowed to be</param>
            <param name="min">The minimum value that value is allowed to be</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>value if validation is ok; otherwise 0.</returns>
        </member>
        <member name="M:Fadd.Validator.Boolean(System.String,System.String,System.Boolean)">
            <summary>
            Checks whether a field contains true (can also be in native language).
            </summary>
            <param name="name">field name</param>
            <param name="value">value to validate</param>
            <param name="required">field is required (may not be null or empty).</param>
            <returns>true if value is true; false if value is false or if validation failed.</returns>
            <seealso cref="F:Fadd.Validator.FieldValueTrue"/>
            <remarks>Check validation errors to see if error ocurred.</remarks>
        </member>
        <member name="M:Fadd.Validator.SetDefaultMgr">
            <summary>
            Set default language.
            </summary>
        </member>
        <member name="P:Fadd.Validator.ContainsErrors">
            <summary>
            true of validation generated errors.
            </summary>
        </member>
        <member name="P:Fadd.Validator.Errors">
            <summary>
            Collection of validation errors.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.PluginFinder">
            <summary>
            General purpose plugin finder class.
            </summary>
            <remarks>
            This class scans a directory after all classes that contains the specified types.
            All assembly checking is done in a separate app domain, which means that no dlls are loaded
            during the process.
            </remarks>
        </member>
        <member name="M:Fadd.Plugins.PluginFinder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.PluginFinder"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginFinder.Find(System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Finds the specified full path.
            </summary>
            <param name="fullPath">Path and wildcards.</param>
            <param name="types">Types wanted.</param>
            <example>
            <code>
            List&gt;Type&lt; types = new List&gt;Type&lt;();
            types.Add(typeof(IPlayer));
            types.Add(typeof(IViewer));
            finder.Find("C:\\myapp\\plugins\\plugin*.dll", types);
            </code>
            </example>
            <exception cref="T:System.Reflection.ReflectionTypeLoadException"></exception>
            <exception cref="T:System.TypeLoadException"></exception>
        </member>
        <member name="M:Fadd.Plugins.PluginFinder.FindInternal(System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Finds the specified full path.
            </summary>
            <param name="fullPath">Path and wildcards.</param>
            <param name="types">Types wanted.</param>
            <example>
            <code>
            List&gt;Type&lt; types = new List&gt;Type&lt;();
            types.Add(typeof(IPlayer));
            types.Add(typeof(IViewer));
            finder.Find("C:\\myapp\\plugins\\plugin*.dll", types);
            </code>
            </example>
            <exception cref="T:System.TypeLoadException"></exception>
        </member>
        <member name="M:Fadd.Plugins.PluginFinder.Add(Fadd.Plugins.PluginTypeInfo@,System.Reflection.Assembly,System.Type,System.Byte[])">
            <summary>
            Adds the specified plugin.
            </summary>
            <param name="plugin">The plugin.</param>
            <param name="assembly">Assembly that the plugin resides in.</param>
            <param name="type">Plugin interface type.</param>
            <param name="publicKey">Public key, should be used to decide the amount of access for the module.</param>
        </member>
        <member name="P:Fadd.Plugins.PluginFinder.Plugins">
            <summary>
            All found plugins
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.CommandPacket">
            <summary>
            Packet sent through the channel. Keeps track of a command and its reply.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.CommandPacket.#ctor(System.Int32,Fadd.Commands.Command)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.CommandPacket"/> class.
            </summary>
            <param name="sequenceNumber">The sequence number.</param>
            <param name="command">Command .</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Like">
            <summary>
            LIKE keyword
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Like.ToString">
            <summary>
            Conditional string
            </summary>
            <returns>" LIKE "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Like.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.BitwiseOperator">
            <summary>
            Operator used for bitwise operations
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.BitwiseOperator.#ctor(System.Char)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Tokens.BitwiseOperator"/> class.
            </summary>
            <param name="token">Bitwise char.</param>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.BitwiseOperator.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>The token wrapped with spaces</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.BitwiseOperator.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessOrEqualToken">
            <summary>
            Parse <![CDATA[<=]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessOrEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessOrEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.MoreThan">
            <summary>
            >
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.MoreThan.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.EqualToken">
            <summary>
            Parse == or =
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.EqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.EqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Globalization.Yaml.YamlLight">
            <summary>
            An implementation of YAML that only support those things that is needed by the Language loader.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Yaml.YamlLight.ParseData(System.String,System.Int32,System.Int32@,System.IO.TextReader)">
            <summary>
             Parses a line
            </summary>
            <param name="line">row in text file</param>
            <param name="offset">where to start the parsing (initial white spaces are excluded)</param>
            <param name="lineNumber">line number in file</param>
            <param name="reader">used if more lines should be read</param>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="T:Fadd.Data.Mappings.XmlLoader">
            <summary>
            Loads mappings from embedded XML files.
            </summary>
            <remarks>
            <para>
            En mapping file can look like this:
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <class name="Gate.BusinessObjects.AdminTodo, Gate.BusinessObjects" table="admin_todos">
              <id name="Id" column="id" type="integer" generator="autoincrement" />
              <property name="Name" column="name" type="string"/>
              <property name="SiteId" column="site_id" type="integer"/>
              <property name="MethodName" column="action" type="string"/>
              <property name="MethodId" column="action_id" type="string"/>
              <property name="Controller" column="controller" type="string"/>
              <property name="Description" column="description" type="string"/>
            </class>
            ]]>
            </code>
            </para>
            <para>
            class 'name' is a assembly qualified name.
            </para>
            <para>
            generator can be 'autoincrement' (works with databases such as SQL Server or MySQL), 'sequence' (works with PostgreSQL, looks for a sequence 
            with the name '[tablename]_id_seq'), 'guid' (Fadd.Data generates the guid), any other values are interpreted as 
            a sequence name (and will be used as such depending on the database type).
            </para>
            <para>
            Property/Id 'type' attribute is not yet used. 
            Will be used along with the 'length' attribute when creating/upgrading tables/columns.
            </para>
            </remarks>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlLoader.#ctor(System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.XmlLoader"/> class.
            </summary>
            <param name="assembly">An assembly to look in.</param>
            <remarks>
            You can add more assemblies by using <see cref="M:Fadd.Data.Mappings.XmlLoader.AddAssembly(System.Reflection.Assembly)"/>
            </remarks>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlLoader.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add another assembly that mappings can be found in.
            </summary>
            <param name="assembly">Assembly to add.</param>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlLoader.FindClass(System.String)">
            <summary>
            Scan after types that match the name.
            </summary>
            <param name="className">name of class to scan for</param>
            <returns>A list with matches.</returns>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlLoader.GetMapping(System.String)">
            <summary>
            Get an mapping.
            </summary>
            <param name="className">Name of class.</param>
            <returns><see cref="T:Fadd.Data.Mappings.IMapping"/> if found; otherwise null.</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">Failed to find any attributes in the class element.</exception>
        </member>
        <member name="T:Fadd.Data.Mappings.MappingException">
            <summary>
            Throw during mapping exceptions.
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.MappingException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.MappingException"/> class.
            </summary>
            <param name="msg">Error message.</param>
            <param name="mappingType">Type that the mapping failed for.</param>
        </member>
        <member name="M:Fadd.Data.Mappings.MappingException.#ctor(System.Type,System.String,System.Data.Common.DbException)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.MappingException"/> class.
            </summary>
            <param name="msg">Error message.</param>
            <param name="innerException">Inner exception.</param>
            <param name="mappingType">Type that the mapping failed for.</param>
        </member>
        <member name="P:Fadd.Data.Mappings.MappingException.MappingType">
            <summary>
            Type that the mapping failed for.
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateRegularExpression">
            <summary>
            Let's you validate a string field using regular expressions.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateRegularExpression.#ctor(System.Object,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateRegularExpression"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="languageName">Name in language text to use, or a error message.</param>
            <seealso cref="M:Fadd.Validation.ValidateRegularExpression.Format(System.String,Fadd.Globalization.ILanguageNode)"/>
            <example>
            // will use the supplied text as error message if validation fails.
            [ValidateRegularExpression("^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9_\.\-]+\.[a-zA-Z]{2,4}$", "Incorrect email")] 
            public string Email{get;set;}
            
            //will use the InvalidEmail text from the language file
            [ValidateRegularExpression("^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9_\.\-]+\.[a-zA-Z]{2,4}$", "InvalidEmail")] 
            public string Email{get;set;}
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateRegularExpression.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation or if value is empty; otherwise false.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ValidateRegularExpression.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateRegularExpression.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="P:Fadd.Validation.ValidateRegularExpression.Value">
            <summary>
            Regular Expression
            </summary>
        </member>
        <member name="T:Fadd.Plugins.PluginStartedEventArgs`1">
            <summary>
            Arguments for <see cref="T:Fadd.Plugins.PluginStartedHandler`1"/>
            </summary>
            <typeparam name="T">A plugin implementation</typeparam>
        </member>
        <member name="M:Fadd.Plugins.PluginStartedEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.PluginStartedEventArgs`1"/> class.
            </summary>
            <param name="plugin">Plugin that have been started.</param>
        </member>
        <member name="P:Fadd.Plugins.PluginStartedEventArgs`1.Plugin">
            <summary>
            Plugin that have been started.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.PluginStartedHandler`1">
            <summary>
             Triggered when a plugin have been started.
            </summary>
            <param name="source">Plugin manager</param>
            <param name="args">Plugin instance</param>
            <typeparam name="T">A plugin implementation</typeparam>
        </member>
        <member name="T:Fadd.Plugins.PluginManager`1">
            <summary>
            This class is responsible of loading all modules in a system.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.IApplication">
            <summary>
            Application interface exposed to the clients.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.#ctor(Fadd.Plugins.IApplication)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.PluginManager`1"/> class.
            </summary>
            <param name="application">Interface exposed to plugins.</param>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.PluginManager`1"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.GetEvidence(Fadd.Plugins.PluginTypeInfo)">
            <summary>
            Called when a plugin assembly is about to be loaded.
            </summary>
            <param name="typeInfo">Information about the assembly.</param>
            <returns>Evidence that the <see cref="T:System.Reflection.Assembly"/> should be loaded with.</returns>
            <remarks>
            The assembly is used to determine which security settings a plugin <see cref="T:System.Reflection.Assembly"/> should be loaded with.
            </remarks>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.LoadModules">
            <summary>
            Loads modules with the correct <see cref="T:System.Security.Policy.Evidence"/> and correct protection level.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.StartModules(System.Collections.Generic.IDictionary{System.String,`0},System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Loads all modules that can be loaded (their dependencies have been loaded.)
            </summary>
            <param name="loaded"></param>
            <param name="dependent"></param>
            <returns></returns>
            <remarks>Call this method as long as it returns true.</remarks>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.OnPluginLoaded(`0,System.Reflection.Assembly,Fadd.Plugins.PluginTypeInfo)">
            <summary>
            Called when a plugin have been loaded.
            </summary>
            <param name="plugin">Module being loaded.</param>
            <param name="assembly">Assembly that the plugin exist in.</param>
            <param name="typeInfo">information about the plugin</param>
            <remarks>Plugin have not been started yet.</remarks>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.Add(`0)">
            <summary>
            Manually add a plugin
            </summary>
            <param name="plugin">Plugin to add</param>
            <remarks>
            Used if you want to inject a known plugin to let it be loaded when all dependencies have been met.
            </remarks>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.Start">
            <summary>
            Loads all modules
            </summary>
        </member>
        <member name="M:Fadd.Plugins.PluginManager`1.StartPlugin(`0)">
            <summary>
            Calls start in a <see cref="T:Fadd.Plugins.IPlugin"/>.
            </summary>
            <param name="plugin">plugin to start</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="E:Fadd.Plugins.PluginManager`1.PluginsLoaded">
            <summary>
            Triggered when all plugins have been loaded, but not started yet.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginManager`1.Item(System.String)">
            <summary>
            Access a loaded plugin.
            </summary>
            <value>plugin if found; otherwise null.</value>
        </member>
        <member name="P:Fadd.Plugins.PluginManager`1.PluginPath">
            <summary>
            Folder in which plugins resides.
            </summary>
            <remarks>Can also contain wildcards</remarks>
            <example>
            <code>
            pluginMgr.Path = "plugins\\plugin*.dll";
            </code>
            </example>
        </member>
        <member name="P:Fadd.Plugins.PluginManager`1.IgnoredPlugins">
            <summary>
            All plugins that should not be loaded.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.PluginManager`1.Plugins">
            <summary>
            A list with all loaded plugins.
            </summary>
        </member>
        <member name="E:Fadd.Plugins.PluginManager`1.PluginLoaded">
            <summary>
            A plugin have been loaded into the system
            </summary>
        </member>
        <member name="E:Fadd.Plugins.PluginManager`1.PluginStarted">
            <summary>
            A plugin have been started.
            </summary>
        </member>
        <member name="E:Fadd.Plugins.PluginManager`1.EvidenceRequested">
            <summary>
            An plugin assembly is about to be loaded and the system needs to know which <see cref="T:System.Security.Policy.Evidence"/> the plugin assembly should be loaded with.
            </summary>
            <remarks>
            Plugins are loaded into the Internet zone per default.
            </remarks>
        </member>
        <member name="E:Fadd.Plugins.PluginManager`1.ApplicationRequested">
            <summary>
            Called when a plugin is about to be started and we need to get the application interface
            that should be used when starting the plugin.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.IPlugin">
            <summary>
            All plugins must derive this interface.
            </summary>
        </member>
        <member name="M:Fadd.Plugins.IPlugin.Start(Fadd.Plugins.IApplication)">
            <summary>
            Start the module
            </summary>
            <param name="application">Application interface exposed towards the plugins.</param>
        </member>
        <member name="P:Fadd.Plugins.IPlugin.PluginName">
            <summary>
            This name is used to determine dependencies, should always be in english. 
            Should not be confused with the human friendly name in <see cref="P:Fadd.Plugins.IPlugin.PluginInfo"/>.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.IPlugin.PluginInfo">
            <summary>
            Information about the plugin.
            </summary>
        </member>
        <member name="P:Fadd.Plugins.IPlugin.Dependencies">
            <summary>
            Other plugins that this one depends on. The list should contain <see cref="P:Fadd.Plugins.IPlugin.PluginName"/>s.
            </summary>
            <value>should never be null.</value>
        </member>
        <member name="T:Fadd.MonthSpan">
            <summary>
            Calculates the number of months and days between two dates (and add the overlapping days).
            </summary>
        </member>
        <member name="M:Fadd.MonthSpan.Create(System.DateTime,System.DateTime)">
            <summary>
            Creates a monthspan between two dates
            </summary>
            <param name="from">from which date to calculate.</param>
            <param name="to">end date.</param>
            <returns>Number of months and days between the two dates.</returns>
        </member>
        <member name="P:Fadd.MonthSpan.Months">
            <summary>
            Number of months
            </summary>
        </member>
        <member name="P:Fadd.MonthSpan.Days">
            <summary>
            Number of days
            </summary>
        </member>
        <member name="T:Fadd.Compiler">
            <summary>
            A general code compiler used to compile objects at runtime.
            </summary>
            <remarks>
            This class is NOT thread safe.
            </remarks>
        </member>
        <member name="M:Fadd.Compiler.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Compiler"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Compiler.Add(System.Type)">
            <summary>
            Add a type that is used in the generated object
            </summary>
            <param name="type">the type</param>
        </member>
        <member name="M:Fadd.Compiler.CheckTypes">
            <summary>
            Fills name spaces and assemblies with info from the added types.
            </summary>
        </member>
        <member name="M:Fadd.Compiler.Compile(System.String)">
            <summary>
            Compile the code.
            </summary>
            <param name="code">C# code.</param>
            <returns>An assembly containing the compiled objects</returns>
            <exception cref="T:System.InvalidOperationException">If compilation fails.</exception>
        </member>
        <member name="M:Fadd.Compiler.CreateInstance``1(System.Object[])">
            <summary>
            Create a new object of the specified type
            </summary>
            <param name="contructorArguments">Constructor parameters</param>
            <typeparam name="T">Type of object to create</typeparam>
            <returns>object if we could create it; otherwise null</returns>
        </member>
        <member name="M:Fadd.Compiler.GetTypeName(System.Type)">
            <summary>
            Used to get correct names for generics.
            </summary>
            <param name="type">Type to generate a strig name for.</param>
            <returns>Type as a code string</returns>
            <example>
            <code>
            <![CDATA[
            string typeName = typeof(List<string>).Name; // will become: List`1
            typeName = Compiler.GetTypeName(typeof(List<string>)); // will become: System.Collections.Generic.List<string>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Fadd.Compiler.GetTypeName(System.Type,System.Boolean)">
            <summary>
            Used to get correct names for generics.
            </summary>
            <param name="type">Type to generate a strig name for.</param>
            <param name="useFullName">true if FullName should be used (including namespace in typename)</param>
            <returns>Type as a code string</returns>
            <example>
            <code>
            <![CDATA[
            string typeName = typeof(List<string>).Name; // will become: List`1
            typeName = Compiler.GetTypeName(typeof(List<string>)); // will become: System.Collections.Generic.List<string>
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Fadd.CompilerException">
            <summary>
            Thrown if code compilation fails.
            </summary>
            <remarks>
            <see cref="P:System.Exception.Data"/> contains an item called <c>code</c> which contains the compiled code.
            </remarks>
        </member>
        <member name="M:Fadd.CompilerException.#ctor(System.String,System.CodeDom.Compiler.CompilerErrorCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.CompilerException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
            <param name="errorCollection">A list with all compiler generated errors.</param>
        </member>
        <member name="M:Fadd.CompilerException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <PermissionSet>
            	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/>
            </PermissionSet>
        </member>
        <member name="P:Fadd.CompilerException.Errors">
            <summary>
            A list with all compiler generated errors.
            </summary>
        </member>
        <member name="T:Fadd.Commands.TypeMapping">
            <summary>
            The purpose of this class is to maintain all delegates for
            one of following types: attributes, interfaces and classes.
            </summary>
            <remarks>
            These lists are used to map all commands to their subscribers.
            </remarks>
        </member>
        <member name="M:Fadd.Commands.TypeMapping.Add(System.Type,Fadd.Commands.CommandHandler)">
            <summary>
            Add a handler
            </summary>
            <param name="key"></param>
            <param name="handler"></param>
            <exception cref="T:System.ArgumentException">If handler have been added already.</exception>
        </member>
        <member name="M:Fadd.Commands.TypeMapping.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#Type@System#Collections#Generic#List{Fadd#Commands#CommandHandler}}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Fadd.Commands.TypeMapping.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Fadd.Commands.Tests.GenericTestObject`2">
            <summary>
            Test object using generic types
            </summary>
            <typeparam name="T">The first value to use the type of</typeparam>
            <typeparam name="K">The second value to use the type of</typeparam>
        </member>
        <member name="M:Fadd.Commands.Tests.GenericTestObject`2.TestIt(System.String,System.Int32)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">String format</param>
            <param name="value">A value to use in the string</param>
            <returns>string.Format(myArg, value, typeof(T), typeof(K))</returns>
        </member>
        <member name="M:Fadd.Commands.Tests.GenericTestObject`2.TestIt(System.String,System.Boolean)">
            <summary>
            Tests it.
            </summary>
            <param name="myArg">String format</param>
            <param name="value">A value to use in the string</param>
            <returns>string.Format(myArg, value, typeof(T), typeof(K))</returns>
        </member>
        <member name="M:Fadd.Commands.Tests.GenericTestObject`2.RetrieveGenericDictionary``2(System.EventHandler{System.EventArgs})">
            <summary>
            Retrieves a dictionary using the two specified types with some random arguments in
            </summary>
        </member>
        <member name="M:Fadd.Commands.Tests.GenericTestObject`2.DoThis">
            <summary>
            Does the this.
            </summary>
        </member>
        <member name="P:Fadd.Commands.Tests.GenericTestObject`2.Id">
            <summary>
            Modify the id of the testobject
            </summary>		
        </member>
        <member name="T:Fadd.Commands.CommandHandler">
            <summary>
            Delegate used to handle commands.
            </summary>
            <param name="source"><see cref="T:Fadd.Commands.ICommandDispatcher"/> that the command was invoked in.</param>
            <returns>true if command was handled.</returns>
            <param name="args">command arguments.</param>
        </member>
        <member name="T:Fadd.Commands.CommandEventArgs">
            <summary>
            Event arguments for <see cref="T:Fadd.Commands.CommandHandler"/>.
            </summary>
        </member>
        <member name="M:Fadd.Commands.CommandEventArgs.#ctor(Fadd.Commands.Command)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.CommandEventArgs"/> class.
            </summary>
            <param name="command">command that was invoked.</param>
        </member>
        <member name="M:Fadd.Commands.CommandEventArgs.#ctor(Fadd.Commands.Command,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.CommandEventArgs"/> class.
            </summary>
            <param name="command">command that was invoked.</param>
            <param name="isAsynchrounous">Command is being invoked asynchrounosly.</param>
        </member>
        <member name="P:Fadd.Commands.CommandEventArgs.Command">
            <summary>
            Command that was invoked.
            </summary>
        </member>
        <member name="P:Fadd.Commands.CommandEventArgs.CancelPropagation">
            <summary>
            Abort the handled of this command.
            </summary>
            <remarks>
            The event <see cref="E:Fadd.Commands.CommandManager.PropagationCancelled"/> can override this property.
            </remarks>
        </member>
        <member name="P:Fadd.Commands.CommandEventArgs.IsAsynchronous">
            <summary>
            Command is being invoked asynchrounosly.
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.NotEqual">
            <summary>
            Not equal condition
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.NotEqual.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" &lt;&gt; "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.NotEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.MoreOrEqual">
            <summary>
            >=
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.MoreOrEqual.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" &gt;= "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.MoreOrEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyToken">
            <summary>
            Parsing a property
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.PropertyToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.SqlTokenIds">
            <summary>
            All tokens used during parsing
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.SqlTokenIds.And">
            <summary>
            AND
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.SqlTokenIds.Or">
            <summary>
            OR
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.SqlTokenIds.In">
            <summary>
            IN ( XXX )
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.SqlTokenIds.StartNesting">
            <summary>
            (
            </summary>
        </member>
        <member name="F:Fadd.Parser.SimpleSQL.SqlTokenIds.EndNesting">
            <summary>
            )
            </summary>
        </member>
        <member name="T:Fadd.Parser.ParseTree">
            <summary>
            A generated tree with all tokens from the text
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTree.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.ParseTree"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTree.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.ParseTree"/> class.
            </summary>
            <param name="trailLength">Number of items to keep in the <see cref="P:Fadd.Parser.ParseTree.Trail"/>.</param>
        </member>
        <member name="M:Fadd.Parser.ParseTree.Add(Fadd.Parser.Token)">
            <summary>
            Add a new token to the tree.
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:Fadd.Parser.ParseTree.AddChild(Fadd.Parser.Token)">
            <summary>
            Adds a child node.
            </summary>
            <param name="token">Token to be added as a child.</param>
            <remarks>this method will also set the token as <see cref="P:Fadd.Parser.ParseTree.Current"/>.</remarks>
            todo: remove this one and fix haml
        </member>
        <member name="M:Fadd.Parser.ParseTree.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Fadd.Parser.ParseTree.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Fadd.Parser.ParseTree.IntoNode">
            <summary>
            Next item is a child to the current node.
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTree.OutOfNode">
            <summary>
            Go out of one level of nesting.
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTree.Reset">
            <summary>
            Back to root node.
            </summary>
        </member>
        <member name="M:Fadd.Parser.ParseTree.ToString">
            <summary>
            Displays parse tree as a tree.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fadd.Parser.ParseTree.Current">
            <summary>
            Current node
            </summary>
        </member>
        <member name="P:Fadd.Parser.ParseTree.Item(System.Int32)">
            <summary>
            Get one of the children
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Fadd.Parser.ParseTree.Count">
            <summary>
            Number of root items.
            </summary>
        </member>
        <member name="P:Fadd.Parser.ParseTree.LastInserted">
            <summary>
            The node that was inserted last.
            </summary>
        </member>
        <member name="P:Fadd.Parser.ParseTree.Trail">
            <summary>
            A trail with the <see cref="P:Fadd.Parser.ParseTree.TrailLength"/> number of previously added nodes, independent of the tree/depth.
            </summary>
        </member>
        <member name="P:Fadd.Parser.ParseTree.TrailLength">
            <summary>
            Number of items to keep in the trail.
            </summary>
            <remarks>
            Specified in the constructor, default value is 3.
            </remarks>
        </member>
        <member name="P:Fadd.Parser.ParseTree.Root">
            <summary>
            Root in the tree.
            </summary>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.Or">
            <summary>
            OR condition ("||" in C#)
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.Or.ToString">
            <summary>
            OR condition as string
            </summary>
            <returns>" || "</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.Or.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Data.Migration.SqlXmlMigrator`1">
            <summary>
            As the name implies the migrator uses sql specified for a certain driver to update the database.
            The sql is loaded using manifest resource xml files named xxxxx.fdmig.xml (fadd data migration)
            </summary>
            <remarks>
            The fdmig file should look like the following
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <migrations>
                <migration name="My migration" version="0002">
                    <description>
                        An optional description of the migration.
                    </description>
            
                    <sql driver="MySql 1.0">
                        alter table myTable rename column myColumn to myColumnValues;
                    </sql>
            
                    <sql driver="SqlServer">
                        alter table myTable rename column myColumn to myColumnValues;
                    </sql>
                </migration>
            
                <migration name="My next migration" version="0003" description="A short description">
                    <!-- default driver will be used if specified and db doesn't match any other driver -->
                    <sql driver="default">
                        INSERT INTO myTable (myId, myValue) VALUES (13, '23123');
                    </sql>
                </migration>
                
            </migrations>
            ]]>
            </remarks>
        </member>
        <member name="T:Fadd.Data.Migration.IMigrator">
            <summary>
            Inteface for a handler of database updating
            </summary>
        </member>
        <member name="M:Fadd.Data.Migration.IMigrator.Migrate(Fadd.Data.DataLayer)">
            <summary>If changes has been made the migrator should update the database accordingly</summary>
            <param name="dataLayer">Used for saving migration data to the database</param>
        </member>
        <member name="M:Fadd.Data.Migration.SqlXmlMigrator`1.#ctor(System.Reflection.Assembly[])">
            <summary>Initializes the <see cref="T:Fadd.Data.Migration.SqlXmlMigrator`1"/></summary>
            <param name="assemblies">Assemblies to look for fdmig.xml files in</param>
        </member>
        <member name="M:Fadd.Data.Migration.SqlXmlMigrator`1.FetchMigrations">
            <summary>Reads all manifest files ending with fdmig.xml and creates migrations from them</summary>
        </member>
        <member name="M:Fadd.Data.Migration.SqlXmlMigrator`1.ParseMigration(System.Xml.XmlTextReader)">
            <summary>Parses the current 'migration' element in the reader and adds its value to the collection of migrations</summary>
            <param name="reader">The reader to parse the migration from</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reader"/> is null</exception>
            <exception cref="T:Fadd.Data.Migration.MigrationXmlException">Throw if parsing failes due to invalid data in xml</exception>
        </member>
        <member name="T:Fadd.Data.Migration.SqlMigration">
            <summary>Holds information about a specific migration</summary>
        </member>
        <member name="F:Fadd.Data.Migration.SqlMigration._sql">
            <summary>Sql for migration keyed by driver name (or default)</summary>
        </member>
        <member name="T:Fadd.CurrentCulture">
            <summary>
            Class to provide transparent retrieval of LCID for silverlight and normal .Net projects
            </summary>
        </member>
        <member name="P:Fadd.CurrentCulture.LCID">
            <summary>
            Gets the LCID for the current thread
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateDigitsAttribute">
            <summary>
            Makes sure that only digits have been entered.
            </summary>
            <para>
            Language file items:
            <list type="table">
                <listheader>
                    <term>ItemName</term>
                    <description>Language text</description>
                </listheader>
                <item>
                    <term>Digits</term>
                    <description>'{0}' may only contain digits.</description>
                </item>
                <item>
                    <term>DigitsExtra</term>
                    <description>'{0}' may only contain digits and "{1}".</description>
                </item>
            </list>
            </para>
        </member>
        <member name="F:Fadd.Validation.ValidateDigitsAttribute.Name">
            <summary>
            Name used in language files.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateDigitsAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateAttribute"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateDigitsAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateAttribute"/> class.
            </summary>
            <param name="extraChars">extra characters that are valid.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateDigitsAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
        </member>
        <member name="M:Fadd.Validation.ValidateDigitsAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateDigitsAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is supported.</returns>
        </member>
        <member name="T:Fadd.ItemEventArgs`1">
            <summary>
            General purpose arguments class for events containing only one item.
            </summary>
            <typeparam name="T">Type of item</typeparam>
        </member>
        <member name="M:Fadd.ItemEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.ItemEventArgs`1"/> class.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Fadd.ItemEventArgs`1.Item">
            <summary>
            Gets or sets the item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyTypeNameGenerator">
            <summary>
            Class to generate readable names from arbitrary types
            </summary>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyTypeNameGenerator.StripGenerics(System.String,System.Int32)">
            <summary>
            Removes any `X from generic type names, ie Dictionary`2.
            If the name lacks any `X entry ie Int32 it will simply be left untouched
            </summary>
            <param name="name">The name to strip from generic parameter count</param>
            <param name="arguments">Number of arguments held</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyTypeNameGenerator.GetName(System.Type)">
            <summary>
            Retrieves the name of the class, ie for <see cref="T:System.Collections.Generic.Dictionary`2"/> =&gt; Dictionary
            </summary>
            <param name="type">The type to generate a name for</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyTypeNameGenerator.GetGenericName(System.Type)">
            <summary>
            <![CDATA[
            Retrieves name of class including any generic types, ie Dictionary<int, string>
            ]]>
            </summary>
            <param name="type">The type to generate a name for</param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyTypeNameGenerator.GetTypedName(System.Type)">
            <summary>
            Retrieves a name of the type with any generic type arguments joined with name.
            </summary>
            <param name="type">The type to generate a name for</param>
            <example>
            <![CDATA[
            Dictionary<int, string> => DictionaryInt32String.
            Useful for naming ie arbitrary methods when building objects using reflection.
            ]]>
            </example>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyTypeNameGenerator.GetFullName(System.Type)">
            <summary>
            Retrieves the full name of a class, ie System.Collections.Generic.Dictionary
            </summary>
            <param name="type">The type to return the full name for</param>
        </member>
        <member name="T:Fadd.Commands.Net.Binding">
            <summary>
            A object binding. Used to copy properties from one object to another.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.Binding.Copy(System.Object,System.Object)">
            <summary>
            Copies the specified from.
            </summary>
            <param name="from">object to copy from.</param>
            <param name="to">objec to copy to.</param>
            <exception cref="T:System.ArgumentNullException">If either from or to are null</exception>
            <exception cref="T:System.ArgumentException">If "to" is not assignabled from "from".</exception>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Where">
            <summary>
            WHERE clause
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Where.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" WHERE "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Where.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessThanToken">
            <summary>
            Parse <![CDATA[<]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessThanToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.LessThanToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.MoreOrEqual">
            <summary>
            >=
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.MoreOrEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyToken">
            <summary>
            Parsing a property
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.PropertyToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.MoreOrEqualToken">
            <summary>
            Parse >=
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.MoreOrEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.MoreOrEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.AndToken">
            <summary>
            Parse 'AND'
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.AndToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.AndToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Globalization.DateTimeHelper">
            <summary>
            Used to parse and format date/times using the current language.
            </summary>
            todo: Copy latest documentation from IDateTimeHelper.
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.Add(System.Int32,Fadd.Globalization.IDateTimeHelper)">
            <summary>
            Add a parser.
            </summary>
            <param name="lcid"></param>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.AddDefaultParsers">
            <summary>
            Add default language parsers.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseDateTime(System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default DateTime.Parse method if date is in an unknown format.
            </summary>
            <param name="value">date/time string</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseDateTime(System.String,System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default DateTime.Parse method if date is in an unknown format.
            </summary>
            <param name="date">date string (may be null/empty).</param>
            <param name="time">time string (may be null/empty).</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseDate(System.String)">
            <summary>
            Tries to parse a date string.
            </summary>
            <param name="value">Can contain a complete date or parts of it (which parts depends on the country).</param>
            <returns>A <see cref="T:System.DateTime"/> containing the date (time is 0) if parsed successfully; otherwise <see cref="F:System.DateTime.MinValue"/>.</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseDate(System.String,System.Int32[],System.Int32)">
            <summary>
            Tries to parse a date string.
            </summary>
            <param name="value">Can contain a complete date or parts of it (which parts depends on the country).</param>
            <param name="values">array that parsed values are written to.</param>
            <param name="offset">where in array to start write values</param>
            <returns>true if parsed successfully; otherwise false</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseTime(System.String)">
            <summary>
            Tries to parse a time string.
            </summary>
            <param name="value">Can contain a complete time or parts of it (which parts depends on the country).</param>
            <returns>A <see cref="T:System.DateTime"/> containing the time (date is 0) if parsed successfully; otherwise <see cref="F:System.DateTime.MinValue"/>.</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ParseTime(System.String,System.Int32[],System.Int32)">
            <summary>
            Tries to parse a time string.
            </summary>
            <param name="value">Can contain a complete time or parts of it (which parts depends on the country).</param>
            <param name="values">array that will be filled. Must contain three slots.</param>
            <param name="offset">Where in the array to start write values</param>
            <returns>true if parsed successfully; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ValidateDate(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate a date.
            </summary>
            <param name="year">year value</param>
            <param name="month">month value</param>
            <param name="day">day value</param>
            <param name="throwException">true if exceptions should be thrown on incorrect values.</param>
            <returns>true if specified values are a correct date; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.ValidateTime(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate 
            </summary>
            <param name="hour">hour</param>
            <param name="minute">minute</param>
            <param name="second">second</param>
            <param name="throwException">true if exceptions should be thrown on incorrect values.</param>
            <returns>true if specified values are a correct date; otherwise false.</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.FormatDate(System.DateTime)">
            <summary>
            Format a date as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday", "On monday"</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.FormatDateTime(System.DateTime)">
            <summary>
            Format a date/time as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday at 12:20pm", "On monday at 11:38am"</returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.GetDuration(System.DateTime,System.DateTime,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            <param name="measures">Number of time units to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.GetDuration(System.DateTime,System.DateTime)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.GetDuration(System.TimeSpan,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            /// <param name="measures">Number of time measures to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
            <remarks><see cref="F:Fadd.Globalization.DurationDetail.Months"/> cannot be used when using this method since counting of months
            requires both to and from datetime information, in such a case user <see cref="M:Fadd.Globalization.DateTimeHelper.GetDuration(System.DateTime,System.DateTime,Fadd.Globalization.DurationDetail,System.Int32)"/></remarks>
        </member>
        <member name="M:Fadd.Globalization.DateTimeHelper.GetDuration(System.TimeSpan)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
        </member>
        <member name="T:Fadd.Data.TransactionEventArgs">
            <summary>
            Event arguments for transaction events.
            </summary>
        </member>
        <member name="M:Fadd.Data.TransactionEventArgs.#ctor(Fadd.Data.ITransaction,System.Data.IDbConnection)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.TransactionEventArgs"/> class.
            </summary>
            <param name="transaction">Transaction.</param>
            <param name="connection">The connection.</param>
        </member>
        <member name="P:Fadd.Data.TransactionEventArgs.Transaction">
            <summary>
            Transaction that the event is for.
            </summary>
        </member>
        <member name="P:Fadd.Data.TransactionEventArgs.Connection">
            <summary>
            Connection that the transaction is being invoked in.
            </summary>
        </member>
        <member name="T:Fadd.Data.DataLayer">
            <summary>
            Main class in the data access layer.
            </summary>
        </member>
        <member name="M:Fadd.Data.DataLayer.#ctor(Fadd.Data.IConnectionHelper)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
            <param name="connectionHelper">The connection helper.</param>
        </member>
        <member name="M:Fadd.Data.DataLayer.#ctor(Fadd.Data.IConnectionHelper,Fadd.IGenericLogger)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.DataLayer"/> class.
            </summary>
            <param name="connectionHelper">The connection helper.</param>
            <param name="logger">Assign logger to everything.</param>
        </member>
        <member name="M:Fadd.Data.DataLayer.CreateConnection">
            <summary>
            Creates a connection, we use this method instead of the one in
            the connection helper to be able to use transactions (with a single connection).
            </summary>
            <returns>A database connection.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">Failed to create the connection.</exception>
        </member>
        <member name="M:Fadd.Data.DataLayer.CreateCommand(System.Data.IDbConnection)">
            <summary>
            Create a command.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fadd.Data.DataLayer.CreateTransaction(System.Data.IsolationLevel)">
            <summary>
            Creates a new transaction.
            </summary>
            <param name="level">On of the <see cref="T:System.Data.IsolationLevel"/>s.</param>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="M:Fadd.Data.DataLayer.CreateTransaction">
            <summary>
            Creates a new transaction.
            </summary>
            <returns>An object representing the new transaction.</returns>
            <remarks>
            Once the transaction has completed, you must explicitly commit or roll back the transaction by using the Commit or Rollback methods.
            </remarks>
        </member>
        <member name="P:Fadd.Data.DataLayer.IsTransaction">
            <summary>
            Determines if we are a transaction.
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidationError">
            <summary>
            An validation error.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidationError.#ctor(System.String,Fadd.Validation.ValidateAttribute)">
            <summary>
            
            </summary>
            <param name="name">Property/Argument that validation failed for.</param>
            <param name="attribute">Kind of validation that failed.</param>
        </member>
        <member name="P:Fadd.Validation.ValidationError.Name">
            <summary>
            Property/Argument that validation failed for
            </summary>
        </member>
        <member name="P:Fadd.Validation.ValidationError.Attribute">
            <summary>
            Kind of validation that failed
            </summary>
        </member>
        <member name="T:Fadd.Commands.PropagationHandler">
            <summary>
            Delegate used to determine if the command propagation can be cancelled.
            </summary>
            <param name="source">Distlight that the command was going through.</param>
            <param name="args">Event information.</param>
            <returns>true of command can be cancelled.</returns>
            <seealso cref="P:Fadd.Commands.CommandEventArgs.CancelPropagation"/>
        </member>
        <member name="T:Fadd.Commands.PropagationEventArgs">
            <summary>
            Event arguments for <see cref="T:Fadd.Commands.PropagationHandler"/>.
            </summary>
        </member>
        <member name="M:Fadd.Commands.PropagationEventArgs.#ctor(Fadd.Commands.Command,Fadd.Commands.CommandHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.PropagationEventArgs"/> class.
            </summary>
            <param name="command">Command that was cancelled.</param>
            <param name="handler">Handler that cancelled the propagation</param>
        </member>
        <member name="P:Fadd.Commands.PropagationEventArgs.Command">
            <summary>
            Command that was cancelled by a handler
            </summary>
        </member>
        <member name="P:Fadd.Commands.PropagationEventArgs.Handler">
            <summary>
            Handler that which to cancel the command.
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.TestCommand">
            <summary>
            Used to test inner classes.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.TestCommand.CopyReply(Fadd.Commands.Command)">
            <summary>
            Copy all stuff that have been modified by the command handler.
            </summary>
            <param name="from">Command to copy reply from.</param>
        </member>
        <member name="T:Fadd.Commands.Net.BinaryChannel">
            <summary>
            Transports commands in binary format.
            </summary>
        </member>
        <member name="F:Fadd.Commands.Net.BinaryChannel.ObjectReceived">
            <summary>
            Invoked when we have recieved a packet from the remote end.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.BinaryChannel"/> class.
            </summary>
            <param name="socket">The socket.</param>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.BinaryChannel"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Fadd.Commands.Net.BinaryChannel"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Send(System.Object)">
            <summary>
            Sends the specified value.
            </summary>
            <param name="value">object to serialize and send.</param>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Send(System.Byte[])">
            <summary>
             Send a packet to the client.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.ProcessInBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Goes through all incoming bytes and creates a packet.
            One or more calls might be required to get a complete packet.
            </summary>
            <param name="inbuffer">buffer to process</param>
            <param name="index">where to start processing</param>
            <param name="count">total number of bytes in buffer.</param>
            <returns>number of bytes that are handled</returns>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.OnBufferReceived(System.Byte[])">
            <summary>
            Called when a object buffer have been received completely.
            </summary>
            <param name="buffer">The buffer.</param>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Close">
            <summary>
            Closes this instance.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Open(System.Net.IPEndPoint)">
            <summary>
            Connect to an endpoint.
            </summary>
            <param name="endPoint">Where to connect</param>
            <exception cref="T:System.Net.Sockets.SocketException">if connection fails.</exception>
        </member>
        <member name="M:Fadd.Commands.Net.BinaryChannel.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Fadd.Commands.Net.BinaryChannel.ShouldReconnect">
            <summary>
            true if we should reconnect when getting disconnected.
            </summary>
        </member>
        <member name="E:Fadd.Commands.Net.BinaryChannel.Disconnected">
            <summary>
            Invoked when channel is disconnected (except when <see cref="M:Fadd.Commands.Net.BinaryChannel.Close"/> are called).
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.ObjectReceivedEventArgs">
            <summary>
            Event args for <see cref="T:Fadd.Commands.Net.ObjectReceivedHandler"/>
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.ObjectReceivedEventArgs.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.Net.ObjectReceivedEventArgs"/> class.
            </summary>
            <param name="value">object received from remote end.</param>
        </member>
        <member name="P:Fadd.Commands.Net.ObjectReceivedEventArgs.Object">
            <summary>
            Bytes received from remote end.
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.ObjectReceivedHandler">
            <summary>
            Invoked when an object have been received from the remote end.
            </summary>
            <param name="source">Client that received the object.</param>
            <param name="args">object received.</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.In">
            <summary>
            A IN clause.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.In.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" IN"</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.In.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Count">
            <summary>
            COUNT(*) SQL clause
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Count.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" COUNT(*) "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Count.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Context">
            <summary>
            We are getting into a sub context (nested conditions)
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Context.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>(</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Context.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.NotEqualToken">
            <summary>
            <![CDATA[
            Parse <> or !=
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.NotEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.NotEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.LessThan">
            <summary>
            <![CDATA[
            <
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.LessThan.ToString">
            <summary>
            Less tan condition
            </summary>
            <returns>
            <![CDATA[" < "]]>
            </returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.LessThan.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.LessThanToken">
            <summary>
            Parse <![CDATA[<]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.LessThanToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.LessThanToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Data.Mappings.XmlMappingReader">
            <summary>
            Reads a mapping definition from an XML reader.
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlMappingReader.#ctor(System.Xml.XmlTextReader,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.XmlMappingReader"/> class.
            </summary>
            <param name="reader">Reader containing mapping XML.</param>
            <param name="type">Type that the mapping is for.</param>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlMappingReader.Read">
            <summary>
            Read mapping.
            </summary>
            <returns>Mapping if found</returns>
            <exception cref="T:Fadd.Data.Mappings.MappingException">If mapping is incorrect (syntax).</exception>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlMappingReader.ProcessPropertyAttribute">
            <summary>
            Go through property attributes
            </summary>
            <exception cref="T:Fadd.Data.Mappings.MappingException"><c>MappingException</c>.</exception>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlMappingReader.ProcessPrimaryKeyAttribute">
            <exception cref="T:Fadd.Data.Mappings.MappingException"><c>MappingException</c>.</exception>
        </member>
        <member name="M:Fadd.Data.Mappings.XmlMappingReader.ProcessClassAttribute">
            <exception cref="T:Fadd.Data.Mappings.MappingException"><c>MappingException</c>.</exception>
        </member>
        <member name="T:Fadd.Data.Mappings.Mapping">
            <summary>
            Default mapping implementation
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.Mapping.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.Mapping"/> class.
            </summary>
            <param name="type">Type that the mapping is for.</param>
            <param name="tableName">Name of the database table.</param>
        </member>
        <member name="M:Fadd.Data.Mappings.Mapping.GetColumnName(System.String)">
            <summary>
            Get a column name from a property name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Data.Mappings.Mapping.GetPrimaryKey">
            <summary>
            Gets current primary key.
            </summary>
            <returns>The primary key if exactly ONE is defined; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Data.Mappings.Mapping.Add(System.String,System.String)">
            <summary>
            Add a property mapping
            </summary>
            <param name="propertyName">Class property</param>
            <param name="columnName">Table column</param>
        </member>
        <member name="M:Fadd.Data.Mappings.Mapping.Add(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Add a property mapping
            </summary>
            <param name="propertyName">Class property</param>
            <param name="columnName">Table column</param>
            <param name="isPrimaryKey">True if property is a primary key.</param>
            <param name="generatorType">Type of generator used.</param>
        </member>
        <member name="P:Fadd.Data.Mappings.Mapping.TableName">
            <summary>
            Name of database table.
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.Mapping.Type">
            <summary>
            Type that the mapping is for.
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.Mapping.Properties">
            <summary>
            Gets all properties
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.Mapping.PrimaryKeys">
            <summary>
            Gets all primary keys
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateContainsAttribute">
            <summary>
            Attribute to specify that a property might only contain the specified letters (does not fail if the string is null or empty)
            </summary>
        </member>
        <member name="F:Fadd.Validation.ValidateContainsAttribute.Name">
            <summary>
            The language node item name for the attribute, should be in the form 'Parameter {0} has invalid characters, allowed characters are {1}'
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateContainsAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Validation.ValidateContainsAttribute"/> class.
            </summary>
            <param name="allowedLetters">The allowed letters</param>
        </member>
        <member name="M:Fadd.Validation.ValidateContainsAttribute.Validate(System.Object,System.Object)">
            <summary>
            Validate value
            </summary>
            <param name="context">Can be used to send a context object to the validation class. Useful if you provide your own validation classes which need to get information from your application. <seealso cref="T:Fadd.Validation.BeforeValidationEventArgs"/></param>
            <param name="value">value to validate</param>
            <returns>
            true if value passed the validation; otherwise false.
            </returns>
            <exception cref="T:System.NotSupportedException">If a value not of <see cref="T:System.String"/> type was supplied</exception>
        </member>
        <member name="M:Fadd.Validation.ValidateContainsAttribute.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
        </member>
        <member name="M:Fadd.Validation.ValidateContainsAttribute.SupportsType(System.Type)">
            <summary>
            Determines if the validation class support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if the type is a string</returns>
        </member>
        <member name="T:Fadd.Property">
            <summary>
            General purpose class to get/set properties by specifying their name as text.
            </summary>
            <example>
            <code>
            User user = new User();
            Property.Set(user, "FirstName", "Jonas"); // same as user.FirstName = "Jonas";
            Property.Set(user, "CreatedAt", "2008-12-30 14:00"); // the CreatedAt property is of type DateTime, the Property class automatically converts it from string.
            Property.Set(user, "Age", "20"); // age is int, which means that it will automatically be converted.
            </code>
            </example>
            todo: Add the ability to extend the object with own additions.
        </member>
        <member name="M:Fadd.Property.Set(System.Object,System.String,System.Object)">
            <summary>
            Assign a property value to the specified object.
            </summary>
            <param name="item">Object that has the property</param>
            <param name="propertyName">Name of the property</param>
            <param name="value">Value, this method will try to cast incorrect types (and even try to parse certain types).</param>
            <exception cref="T:System.ArgumentException">If value is not correct (i.e. null when null is not accepted etc)</exception>
            <exception cref="T:System.InvalidOperationException">If assigner object could not be generated.</exception>
            <exception cref="T:System.InvalidCastException">If assigner object can't cast to the correct type.</exception>
            <exception cref="T:System.ArgumentNullException">values is null and it's not allowed for the specified type.</exception>
        </member>
        <member name="M:Fadd.Property.Get(System.Object,System.String)">
            <summary>
            Get a property value from the specified object.
            </summary>
            <param name="item">Object that has the property</param>
            <param name="propertyName">Name of the property</param>
            <returns>property value</returns>
            <exception cref="T:System.ArgumentException">If value is not correct (i.e. null when null is not accepted etc)</exception>
            <exception cref="T:System.InvalidOperationException">If assigner object could not be generated.</exception>
            <exception cref="T:System.InvalidCastException">If assigner object can't cast to the correct type.</exception>
        </member>
        <member name="T:Fadd.IPropertiesObject">
            <summary>
            Base object for property assigner.
            </summary>
        </member>
        <member name="M:Fadd.IPropertiesObject.Set(System.Object,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="propertyName"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fadd.IPropertiesObject.Get(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:Fadd.CanSetHandler">
            <summary>
            Used to determine 
            </summary>
            <param name="instance"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.CountToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.CountToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.NotEqualToken">
            <summary>
            <![CDATA[
            Parse <> or !=
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.NotEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.NotEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Data.Mappings.MirrorLoader">
            <summary>
            Tables and Classes are identical.
            </summary>
            <remarks>
            Since they are identical, we create a mapping which simply returns the
            same values for the mapping.
            </remarks>
        </member>
        <member name="M:Fadd.Data.Mappings.MirrorLoader.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.MirrorLoader"/> class.
            </summary>
            <param name="assembly">Assembly that will be scanned after mappings.</param>
            <param name="generatorType">"sequence" or "autoincrement"</param>
            <remarks>
            Specifying "sequence" means that the system will look for generators/sequences called "[tablename]_id_seq".
            </remarks>
        </member>
        <member name="M:Fadd.Data.Mappings.MirrorLoader.GetMapping(System.String)">
            <summary>
            Gets the mapping.
            </summary>
            <param name="className">Name of the class to get mapping for.</param>
            <returns><see cref="T:Fadd.Data.Mappings.IMapping"/> if found; otherwise null.</returns>
        </member>
        <member name="M:Fadd.Data.Mappings.MirrorLoader.FindClass(System.String)">
            <exception cref="T:System.InvalidOperationException">Multiple classes found.</exception>
        </member>
        <member name="M:Fadd.Data.Mappings.MirrorLoader.Add(System.Reflection.Assembly)">
            <summary>
            Add an assembly in which we can look for mappings.
            </summary>
            <param name="assembly">An assembly</param>
        </member>
        <member name="T:Fadd.Commands.UnhandledExceptionDelegate">
            <summary>
            Delegate used when a unhandled exception have been caught.
            </summary>
        </member>
        <member name="T:Fadd.Commands.UnhandledExceptionEventArgs">
            <summary>
            Arguments for <see cref="T:Fadd.Commands.UnhandledExceptionDelegate"/>
            </summary>
        </member>
        <member name="M:Fadd.Commands.UnhandledExceptionEventArgs.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.UnhandledExceptionEventArgs"/> class.
            </summary>
            <param name="err">caught exception.</param>
        </member>
        <member name="P:Fadd.Commands.UnhandledExceptionEventArgs.Exception">
            <summary>
            Caught exception
            </summary>
        </member>
        <member name="T:Fadd.Commands.Net.ObjectCopier">
            <summary>
            Copies get/set properties from one object to another.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.ObjectCopier.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Fadd.Commands.Net.ObjectCopier"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:Fadd.Commands.Net.ObjectCopier.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Fadd.Commands.Net.ObjectCopier.Copy(System.Object,System.Object)">
            <summary>
            Copies all get/set properties from one object to another.
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Star">
            <summary>
            Star *
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Star.ToString">
            <summary>
            SQL Star 
            </summary>
            <returns>" * "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Star.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Property">
            <summary>
            A property name
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Property.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.SimpleSQL.Tokens.Property"/> class.
            </summary>
            <param name="name">Name of property.</param>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Property.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>column name</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Property.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Property.Name">
            <summary>
            Name of property
            </summary>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Or">
            <summary>
            OR condition ("||" in C#)
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Or.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" OR "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Or.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.StartContext">
            <summary>
            Parse (, which is start of one level nesting.
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StartContext.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.StartContext.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.ParseTreeTokens.EqualToken">
            <summary>
            Parse == or =
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.EqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.EqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.ParameterValueToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.ParameterValueToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.BitwiseToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <param name="tokenizer"></param>
            <param name="tree"></param>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.And">
            <summary>
            <![CDATA[&&]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.And.ToString">
            <summary>
            Returns &amp;&amp;.
            </summary>
            <returns>" &amp;&amp; "</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.And.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="T:Fadd.Parser.Evaluator.ParseTreeTokens.LessOrEqualToken">
            <summary>
            Parse <![CDATA[<=]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.LessOrEqualToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.Evaluator.ParseTreeTokens.LessOrEqualToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Plugins.ApplicationRequestedEventArgs`1">
            <summary>
            Arguments for <see cref="T:Fadd.Plugins.ApplicationRequestedHandler`1"/>
            </summary>
            <typeparam name="T">Plugin type</typeparam>
        </member>
        <member name="M:Fadd.Plugins.ApplicationRequestedEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Plugins.ApplicationRequestedEventArgs`1"/> class.
            </summary>
            <param name="plugin">Plugin being started.</param>
        </member>
        <member name="P:Fadd.Plugins.ApplicationRequestedEventArgs`1.Plugin">
            <summary>
            Plugin being started
            </summary>
        </member>
        <member name="P:Fadd.Plugins.ApplicationRequestedEventArgs`1.Application">
            <summary>
            Application that the plugin should be started with.
            </summary>
        </member>
        <member name="T:Fadd.Plugins.ApplicationRequestedHandler`1">
            <summary>
            A plugin is about to be started and it needs a <see cref="T:Fadd.Plugins.IApplication"/> interface to be passed to it.
            </summary>
            <typeparam name="T">A type that implements <see cref="T:Fadd.Plugins.IPlugin"/>.</typeparam>
            <param name="source"><see cref="T:Fadd.Plugins.PluginManager`1"/></param>
            <param name="args">Arguments.</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.Insert">
            <summary>
            INSERT INTO clause
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.Insert.ToString">
            <summary>
            returns SQL
            </summary>
            <returns>"INSERT INTO "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.Insert.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.WhereToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.WhereToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.EvaluatorTokenIds">
            <summary>
            All tokens used during parsing
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.EvaluatorTokenIds.And">
            <summary>
            AND
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.EvaluatorTokenIds.Or">
            <summary>
            OR
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.EvaluatorTokenIds.In">
            <summary>
            IN ( XXX )
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.EvaluatorTokenIds.StartNesting">
            <summary>
            (
            </summary>
        </member>
        <member name="F:Fadd.Parser.Evaluator.EvaluatorTokenIds.EndNesting">
            <summary>
            )
            </summary>
        </member>
        <member name="T:Fadd.Data.Statement">
            <summary>
            Query statement
            </summary>
        </member>
        <member name="M:Fadd.Data.Statement.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Statement"/> class.
            </summary>
            <param name="conditions">Conditions (corresponds to the WHERE clause) using property names.</param>
            <param name="arguments">Argument values used in the condition.</param>
        </member>
        <member name="M:Fadd.Data.Statement.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Statement"/> class.
            </summary>
        </member>
        <member name="M:Fadd.Data.Statement.OrderBy(System.String[])">
            <summary>
            Properties to sort by. 
            </summary>
            <param name="properties">properties separated by comma, with or without ASC/DESC.</param>
            <returns>the current statement</returns>
            <example>new Statement("FirstName = ?", firstName).OrderBy("LastName DESC, FirstName")</example>
        </member>
        <member name="M:Fadd.Data.Statement.GroupBy(System.String[])">
            <summary>
            Properties to group the statement by
            </summary>
            <param name="properties">Properties to group by, separated by comma.</param>
            <returns></returns>
            <example>new Statement(string.Empty).GroupBy("LastName, FirstName")</example>
        </member>
        <member name="M:Fadd.Data.Statement.Paging(System.Int32,System.Int32)">
            <summary>
            Get a certain amount of entries.
            </summary>
            <param name="page">0 based index. 0 = first page, 1 = second page..</param>
            <param name="itemsPerPage">Number of entries per page.</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Data.Statement.GetHashCode">
            <summary>
            Calculates hash code by concatenating the strings for all statement parts.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fadd.Data.Statement.Arguments">
            <summary>
            Arguments being used in <see cref="T:Fadd.Data.Statement"/>.
            </summary>
        </member>
        <member name="P:Fadd.Data.Statement.Conditions">
            <summary>
            Conditions (corresponds to the WHERE clause) using property names
            </summary>
        </member>
        <member name="P:Fadd.Data.Statement.OrderByClause">
            <summary>
            Property names + ASC/DESC
            </summary>
        </member>
        <member name="P:Fadd.Data.Statement.GroupByClause">
            <summary>
            Property names to group by
            </summary>
        </member>
        <member name="P:Fadd.Data.Statement.Page">
            <summary>
            0 based index. 0 = first page, 1 = second page..
            </summary>
        </member>
        <member name="P:Fadd.Data.Statement.PageSize">
            <summary>
            Number of entries per page
            </summary>
        </member>
        <member name="T:Fadd.Data.ConnectionConfiguration">
            <summary>
            Database connection configuration
            </summary>
        </member>
        <member name="P:Fadd.Data.ConnectionConfiguration.DriverName">
            <summary>
            Assembly qualified name of the .Net driver to use.
            </summary>
        </member>
        <member name="P:Fadd.Data.ConnectionConfiguration.ConnectionString">
            <summary>
            Connection string
            </summary>
        </member>
        <member name="P:Fadd.Data.ConnectionConfiguration.ConnectionType">
            <summary>
            Connection type.
            </summary>
        </member>
        <member name="T:Fadd.Validation.ValidateWebURL">
            <summary>
            Validates a string as  http(s)/ftp url.
            </summary>
        </member>
        <member name="F:Fadd.Validation.ValidateWebURL.Name">
            <summary>
            Name of the language item for this validation.
            </summary>
        </member>
        <member name="M:Fadd.Validation.ValidateWebURL.Format(System.String,Fadd.Globalization.ILanguageNode)">
            <summary>
            Localize error if validation failed.
            </summary>
            <param name="fieldName">Localized field name.</param>
            <param name="validationLanguage">Language node with all validation translations.</param>
            <returns>A localized error message if the validation failed; otherwise null.</returns>
            <example>
            <code>
            attribute.Localize("FirstName", "'{0}' is required"); 
            // will return "'{0}' is required" if the validation failed, else null.
            </code>
            </example>
        </member>
        <member name="M:Fadd.Validation.ValidateWebURL.SupportsType(System.Type)">
            <summary>
            Determines if the validation support the specified type.
            </summary>
            <param name="type">Property/Value type.</param>
            <returns>true if type is supported.</returns>
            <remarks>
            Used when validation objects are generated.
            </remarks>
        </member>
        <member name="M:Fadd.Validation.ValidateWebURL.Validate(System.Object,System.Object)">
            <summary>
            Validate the URL
            </summary>
            <param name="instance">Object instance (of the object being tested).</param>
            <param name="value">Value to test</param>
            <returns>true if value is an URL; otherwise false.</returns>
            <exception cref="T:System.NotSupportedException">If type is not supported.</exception>
        </member>
        <member name="T:Fadd.TabStringBuilder">
            <summary>
            Wrapper for the <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> class adding support for tabbing easily
            </summary>
            <usage><![CDATA[
            TabStringBuilder sb = new TabStringBuilder();
            sb.AppendLineInc("<div>");
            sb.AppendLine(@"<input type=""button"" value=""My Button"" />);
            sb.AppendLineDec("</div>");
            
            Would give the result:
            <div>
            	<input type="button" value="My Button" />
            </div>
            
            Without having you worry about what tab indentation your on, neat!
            ]]></usage>
        </member>
        <member name="M:Fadd.TabStringBuilder.#ctor">
            <summary>
            Instances a blank <see cref="T:Fadd.TabStringBuilder"/>
            </summary>
        </member>
        <member name="M:Fadd.TabStringBuilder.#ctor(System.Text.StringBuilder,System.Int32)">
            <summary>
            Instance the <see cref="T:Fadd.TabStringBuilder"/> with a <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> and a start intendation
            </summary>
            <param name="stringBuilder">A <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> to append text to</param>
            <param name="intendation">
            Can be used to start writing with tabs using a set intendation when data has previously been written to the
            <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> with intendation.
            </param>
        </member>
        <member name="M:Fadd.TabStringBuilder.ToString">
            <summary>
            The built string
            </summary>
            <returns>Generated string</returns>
        </member>
        <member name="M:Fadd.TabStringBuilder.SetIntendation(System.Int32)">
            <summary>
            Changes the <see cref="F:Fadd.TabStringBuilder._tabs"/> to contain the specified number of tab characters
            </summary>
            <param name="intendation">Number of tab characters to set</param>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLine(System.String)">
            <summary>
            Appends tabs followed by the specified value and a line termination to the string
            </summary>
            <param name="value">The value to add</param>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLine(System.Object)">
            <summary>
            Appends tabs followed by the specified value and a line termination to the string
            </summary>
            <param name="value">The value to add</param>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLine">
            <summary>
            Appends a empty line without tabs
            </summary>
        </member>
        <member name="M:Fadd.TabStringBuilder.Append(System.String)">
            <summary>
            Just appends plain string to the underlying <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> without any tabs
            </summary>
            <param name="value">The value to add</param>
        </member>
        <member name="M:Fadd.TabStringBuilder.Append(System.Object)">
            <summary>
            Appends tabs and value to the string
            </summary>
            <param name="value">The value to add</param>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLineInc">
            <summary>
            Adds a new line and increases the tab indendation
            </summary>
            <example><![CDATA[
            sb.Append("<div>");
            sb.AppendLineInc();
            sb.AppendLine("<img src.../>");
            sb.AppendLineDec("</div>");
            
            =>
            <div>
            	<img src.../>
            </div>
            ]]></example>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLineInc(System.String)">
            <summary>
            Appends tabs and value to the string after which the intendation is increased
            </summary>
            <param name="value">The value to append</param>
            <remarks>The tab intendation is increased after adding the value</remarks>
            <example><![CDATA[
            sb.AppendLineInc("<div>");
            sb.AppendLine("<span>Example</span>");
            
            Would give:
            <div>
            	<span>Example</span>
            ]]></example>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLineInc(System.Object)">
            <summary>
            Appends tabs and value to the string after which the intendation is increased
            </summary>
            <param name="value">The value to append</param>
            <remarks>The tab intendation is increased after adding the value</remarks>
            <example><![CDATA[
            sb.AppendLineInc("<div>");
            sb.AppendLine("<span>Example</span>");
            
            Would give:
            <div>
            	<span>Example</span>
            ]]></example>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLineDec(System.String)">
            <summary>
            Decreases the intendation and appends tabs and value to the string
            </summary>
            <param name="value">The value to append</param>
            <remarks>The tab intendation is decreased before adding the value</remarks>
            <example><![CDATA[
            sb.AppendLineInc("<div>");
            sb.AppendLine("<span>Example</span>");
            sb.AppendLineDec("<div>");
            
            Would give:
            <div>
            	<span>Example</span>
            </div>
            ]]></example>
        </member>
        <member name="M:Fadd.TabStringBuilder.AppendLineDec(System.Object)">
            <summary>
            Decreases the intendation and appends tabs and value to the string
            </summary>
            <param name="value">The value to append</param>
            <remarks>The tab intendation is decreased before adding the value</remarks>
            <example><![CDATA[
            sb.AppendLineInc("<div>");
            sb.AppendLine("<span>Example</span>");
            sb.AppendLineDec("<div>");
            
            Would give:
            <div>
            	<span>Example</span>
            </div>
            ]]></example>
        </member>
        <member name="P:Fadd.TabStringBuilder.StringBuilder">
            <summary>
            Retrieves the <see cref="P:Fadd.TabStringBuilder.StringBuilder"/> used by the class
            </summary>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyCommand">
            <summary>
            Command sent by a TypeProxy
            </summary>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyCommand.#ctor(System.Type,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.ObjectProxyCommand"/> class.
            </summary>
            <param name="type">Type of object to execute method on.</param>
            <param name="method">Method to call.</param>
            <param name="arguments">Argumens that should be passed to the method.</param>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyCommand.ReturnValue">
            <summary>
            Return value from method call.
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyCommand.Type">
            <summary>
            Type of object to execute method on.
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyCommand.Method">
            <summary>
            Method to call.
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyCommand.Args">
            <summary>
            Argumens that should be passed to the method call.
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyCommand.Exception">
            <summary>
            Exception thrown during method call
            </summary>
        </member>
        <member name="T:Fadd.Commands.ObjectProxyProperty">
            <summary>
            Class for building information strings about a proxy property
            </summary>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyProperty.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Instantiates and builds information about a property
            </summary>
            <param name="propertyInfo"></param>
        </member>
        <member name="M:Fadd.Commands.ObjectProxyProperty.BuildDeclaration(Fadd.Commands.ObjectProxyProperty)">
            <summary>
            Builds a declaration string for the property proxy
            </summary>
            <param name="property">The property to build a proxy declaration for</param>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.Signature">
            <summary>
            Retrieves a signature for the property, ie _propertyName
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.Name">
            <summary>
            Retrieves the property name
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.ReturnType">
            <summary>
            Retrieves the return type for the property
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.Declaration">
            <summary>
            Retrieves the property declaration string
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.PropertyType">
            <summary>
            Retrieves the property type
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.HasGet">
            <summary>
            Returns true if the property has a get field
            </summary>
        </member>
        <member name="P:Fadd.Commands.ObjectProxyProperty.HasSet">
            <summary>
            Returns true if the property has a set field
            </summary>
        </member>
        <member name="T:Fadd.Commands.AsyncQueueItem">
            <summary>
            Invokes all handlers for a command.
            </summary>
        </member>
        <member name="M:Fadd.Commands.AsyncQueueItem.#ctor(System.Object,Fadd.Commands.Command,Fadd.Commands.CommandManager,System.AsyncCallback,Fadd.Commands.AsyncQueueItemResult)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Commands.AsyncQueueItem"/> class.
            </summary>
            <param name="source">used as "source" in the command event delegate.</param>
            <param name="cmd">command being executed.</param>
            <param name="cmdMgr">Used to check if propagation may be cancelled.</param>
            <param name="callBack">callback when command have been executed..</param>
            <param name="result">async result.</param>
        </member>
        <member name="T:Fadd.Parser.SimpleSQL.Tokens.LessOrEqual">
            <summary>
             <![CDATA[
            <=
            ]]>
            </summary>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.Tokens.LessOrEqual.ToString">
            <summary>
            Returns SQL
            </summary>
            <returns>" &lt;= "</returns>
        </member>
        <member name="P:Fadd.Parser.SimpleSQL.Tokens.LessOrEqual.TokenIdentifier">
            <summary>
            Used to determine the kind of this token
            </summary>
            <value></value>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.SelectToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.SelectToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.CommaToken.Match(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Check if the current position is the start of this token
            </summary>
            <returns>true if our token is the next one.</returns>
        </member>
        <member name="M:Fadd.Parser.SimpleSQL.ParseTreeTokens.CommaToken.Parse(Fadd.Parser.Tokenizer,Fadd.Parser.ParseTree)">
            <summary>
            Parses the data in the specified <see cref="T:Fadd.Parser.Tokenizer"/>.
            </summary>
            <param name="tokenizer">The <see cref="T:Fadd.Parser.Tokenizer"/> containing the data to parse.</param>
            <param name="tree"><see cref="T:Fadd.Parser.ParseTree"/> that is being built..</param>
            <returns>true if more tokens can be parsed on the current leaf; false if we should continue to next leaf (parse no more children).</returns>
        </member>
        <member name="T:Fadd.Parser.Evaluator.Tokens.PropertyValue">
            <summary>
            Contains a value in a condition.
            </summary>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.PropertyValue.#ctor(Fadd.Parser.Evaluator.Tokens.Property)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Parser.Evaluator.Tokens.PropertyValue"/> class.
            </summary>
            <param name="property">Property that this value belongs to.</param>
        </member>
        <member name="M:Fadd.Parser.Evaluator.Tokens.PropertyValue.ToString">
            <summary>
            Question mark as string
            </summary>
            <returns>"?"</returns>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.PropertyValue.TokenIdentifier">
            <summary>
            Identifier for this token.
            </summary>
        </member>
        <member name="P:Fadd.Parser.Evaluator.Tokens.PropertyValue.Property">
            <summary>
            Property that this token belongs to.
            </summary>
        </member>
        <member name="T:Fadd.Globalization.Localizations.DateTimeHelper1053">
            <summary>
            Used to parse Swedish dates and times.
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.#cctor">
            <summary>
            Static constructor setting up helping maps
            </summary>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseDateTime(System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default <see cref="M:System.DateTime.Parse(System.String)"/> method if date is in an unknown format.
            </summary>
            <param name="value">date/time string</param>
            <returns>A <see cref="T:System.DateTime"/> if parsed successfully; otherwise <see cref="F:System.DateTime.MinValue"/>.</returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
            <remarks>
            Can parse one of the following formats:<br/>
            YYYY-MM-DD HH:MM:SS <br/>
            YYYY-MM-DD HH:MM<br/>
            YYYYMMDDHHMM<br/>
            YYYYMMDDHHMMSS<br/>
            YYMMDDHHMM
            </remarks>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseDateTime(System.String,System.String)">
            <summary>
            Will try to parse the date/time using the local parser.
            Will also try the default <see cref="M:System.DateTime.Parse(System.String)"/> method if date is in an unknown format.
            </summary>
            <param name="date">date string. Date will be set to current if value is not specified.</param>
            <param name="time">time string. Time will be set to current if not specified.</param>
            <returns>A <see cref="T:System.DateTime"/></returns>
            <exception cref="T:System.FormatException">If the date/time format is invalid.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If month/day/hour/minute/second are not within their ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseDate(System.String)">
            <summary>
            Tries to parse a date string.
            </summary>
            <param name="value">Can contain a complete date or parts of it (which parts depends on the country).</param>
            <returns>
            A <see cref="T:System.DateTime"/> containing the date (time is 0) if parsed successfully; otherwise <see cref="F:System.DateTime.MinValue"/>.
            </returns>
            <remarks>
            YYYY-MM-DD
            YYYYMMDD
            YYMMDD
            MMDD
            </remarks>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseDate(System.String,System.Int32[],System.Int32)">
            <summary>
            Can parse one of the following formats:
            YYYY-MM-DD
            YYYYMMDD
            YYMMDD
            MMDD
            </summary>
            <param name="value">contains a date string.</param>
            <param name="values">array that parsed values are written to.</param>
            <param name="offset">where in array to start write values</param>
            <exception cref="T:System.FormatException">If value contains an unknown format.</exception>
            <exception cref="T:System.ArgumentException">If month/day are not within their ranges.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>offset</c> is out of range.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseTime(System.String)">
            <summary>
            Tries to parse a time string.
            </summary>
            <param name="value">Can contain a complete time or parts of it (which parts depends on the country).</param>
            <returns>A <see cref="T:System.DateTime"/> containing the time (date is 0) if parsed successfully; otherwise <see cref="F:System.DateTime.MinValue"/>.</returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ParseTime(System.String,System.Int32[],System.Int32)">
            <summary>
            Can parse one of the following formats:
            HH:MM:SS
            HH:MM
            HHMM
            HHMMSS
            </summary>
            <param name="value">a time value</param>
            <param name="values">array that will be filled. Must contain three slots.</param>
            <param name="offset">Where in the array to start write values</param>
            <returns>true if parsed successfully; otherwise false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>offset</c> is out of range.</exception>
            <exception cref="T:System.FormatException">Invalid time format.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ValidateDate(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate a date
            </summary>
            <param name="year">year value</param>
            <param name="month">month value</param>
            <param name="day">day value</param>
            <param name="throwException">throw exceptions</param>
            <returns>true if specified values are a correct date; otherwise false.</returns>
            <exception cref="T:System.ArgumentException">If any of the values are not in the allowed ranges.</exception>
            <exception cref="T:System.FormatException">Month must be between 1 and 12.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ValidateTime(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validate a time value.
            </summary>
            <param name="hour">hour</param>
            <param name="minute">minute</param>
            <param name="throwException">throw exceptions</param>
            <exception cref="T:System.ArgumentException">If any of the values are not in the allowed ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.ValidateTime(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="throwException"></param>
            <exception cref="T:System.ArgumentException">If any of the values are not in the allowed ranges.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.FormatDate(System.DateTime)">
            <summary>
            Format a date as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday", "On monday"</returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.FormatDateTime(System.DateTime)">
            <summary>
            Format a date as a string.
            </summary>
            <param name="dateTime">A date/time</param>
            <returns>Examples: "Yesterday at 12:20pm", "On Monday at 11:38am"</returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetDuration(System.DateTime,System.DateTime,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            <param name="measures">Number of time units to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetDuration(System.DateTime,System.DateTime)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="from">Start time of duration</param>
            <param name="to">End time of duration</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetDuration(System.TimeSpan,Fadd.Globalization.DurationDetail,System.Int32)">
            <summary>
            Get duration as a human friendly string.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
            <param name="durationDetail">The detail in which to display the duration</param>
            <param name="measures">Number of time measures to display</param>
            <returns>
            A string like: 1 month, 2 weeks, and 3 days.
            </returns>
            <remarks><see cref="F:Fadd.Globalization.DurationDetail.Months"/> cannot be used when using this method since counting of months
            requires both to and from date time information, in such a case user <see cref="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetDuration(System.TimeSpan)"/></remarks>
            <exception cref="T:System.InvalidOperationException">Since <see cref="T:System.TimeSpan"/> is given as duration months cannot be calculated, try GetDuration(DateTime, DateTime, DurationDetail) instead.</exception>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetDuration(System.TimeSpan)">
            <summary>
            Get duration as a human friendly string. Displays all time unit durations.
            </summary>
            <param name="span">The timespan for which to output the duration</param>
            <returns></returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetAmount(Fadd.MonthSpan,System.TimeSpan,Fadd.Globalization.DurationDetail,System.Boolean)">
            <summary>
            Displays a value defined by the <see cref="T:Fadd.Globalization.DurationDetail"/> either as a part or as a total
            </summary>
            <param name="monthSpan">Number of months and days</param>
            <param name="timeSpan">TimeSpan containing detailed times</param>
            <param name="getDetail">The time unit to retrieve</param>
            <param name="showTotal">True if the total amount of the time unit should be returned or just a portion of it</param>
            <returns>A string in the form 'amount timunitname, '</returns>
        </member>
        <member name="M:Fadd.Globalization.Localizations.DateTimeHelper1053.GetName(System.String,System.Int32)">
            <summary>
            Retrieves a singular or plural name with amount and comma padded, ie '3 månader, ' or '1 månad, '
            </summary>
            <param name="pluralName">The name in plural (used to map for singular name)</param>
            <param name="amount">The amount to display</param>
        </member>
        <member name="T:Fadd.Data.Mappings.PropertyMapping">
            <summary>
            Mappings for properties.
            </summary>
        </member>
        <member name="M:Fadd.Data.Mappings.PropertyMapping.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.Mappings.PropertyMapping"/> class.
            </summary>
            <param name="propertyName">Name of the class property.</param>
            <param name="columnName">Name of the database column.</param>
        </member>
        <member name="P:Fadd.Data.Mappings.PropertyMapping.ColumnName">
            <summary>
            Gets or sets name in table
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.PropertyMapping.PropertyName">
            <summary>
            Gets or sets name in class.
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.PropertyMapping.IsPrimaryKey">
            <summary>
            Gets or sets whether this property is part of the primary key
            </summary>
        </member>
        <member name="P:Fadd.Data.Mappings.PropertyMapping.Generator">
            <summary>
            Gets or sets how the value is generated.
            </summary>
            <remarks>
            <list type="table">
            <item>
            <term>sequence</term>
            <description>Looks for a sequence named "[tableName]_id_seq"</description>
            </item>
            <item>
            <term>autoincrement</term>
            <description>Uses database specific code to fetch value after insert.
            <para>ONLY VALID FOR PRIMARY KEYS</para>
            </description>
            </item>
            <item>
            <term>guid</term>
            <description>generate a globally unique identifier.</description>
            </item>
            <item>
            <term>any other value</term>
            <description>specifies a sequence/generator name</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Fadd.Data.ConnectionHelpers.PostgreSqlHelper">
            <summary>
            Connection helper specialized for PostgreSQL database.
            </summary>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fadd.Data.ConnectionHelpers.PostgreSqlHelper"/> class.
            </summary>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.CreateConnection">
            <summary>
            Create a new connection to the database.
            </summary>
            <returns>An open database connection.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If connection fails.</exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.GetNextSequenceValue(System.Data.IDbCommand,System.String)">
            <summary>
            Try to get next sequence value.
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction.</param>
            <param name="sequenceName">Name of the sequence/generator.</param>
            <returns>A generated value.</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.GetAutoIncrementValue(System.Data.IDbCommand,System.String)">
            <summary>
            Gets the latest auto incremented value from the database.
            </summary>
            <param name="command">A command to perform actions with, we pass commands since they might be in a transaction..</param>
            <param name="columnName">Name of the column that the auto incremented value is for.</param>
            <returns>auto incremented value</returns>
            <exception cref="T:Fadd.Data.DataLayerException">If something failed </exception>
            <exception cref="T:System.NotSupportedException">Not supported by PostgreSQL</exception>
        </member>
        <member name="M:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.Paging(Fadd.Data.Mappings.IMapping,System.String,System.Int32,System.Int32)">
            <summary>
            Modifies the SQL statement to include paging.
            </summary>
            <param name="mapping">Mapping used by certain implementations (but not by this one).</param>
            <param name="sqlStatement">SQL statement generated by the DAL.</param>
            <param name="page">0 based index</param>
            <param name="pageSize">number of entries per page</param>
            <returns>SQL statement with paging</returns>
            <example>
            	<code>
            helper.Paging("SELECT * FROM users", 5, 10); // --&gt; "SELECT * FROM users LIMIT 10 OFFSET 50"
            </code>
            </example>
        </member>
        <member name="P:Fadd.Data.ConnectionHelpers.PostgreSqlHelper.ConnectionString">
            <summary>
            Connection string
            </summary>
            <value></value>
        </member>
    </members>
</doc>
