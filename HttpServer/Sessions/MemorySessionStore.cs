using System;
using System.Collections.Generic;
using System.Threading;

namespace HttpServer.Sessions
{
    /// <summary>
    /// Session store using memory for each session.
    /// </summary>
    public class MemorySessionStore : IHttpSessionStore
    {
        private readonly IDictionary<string, IHttpSession> _sessions = new Dictionary<string, IHttpSession>();
        private readonly Queue<IHttpSession> _unusedSessions = new Queue<IHttpSession>();
        private int _expireTime = 20;
    	private Timer _expireTimer;

		/// <summary>
		/// Initializes the class setting the expirationtimer to clean the session every minute
		/// </summary>
		public MemorySessionStore()
		{
			 _expireTimer = new Timer(Cleanup, null, 60000, 60000);
		}

		/// <summary>
		/// Delegate for the cleanup timer
		/// </summary>
		private void Cleanup(object o)
		{
			Cleanup();
		}

        #region IHttpSessionStore Members

        /// <summary>
        /// Load a session from the store
        /// </summary>
        /// <param name="sessionId"></param>
        /// <returns>null if session is not found.</returns>
        public IHttpSession this[string sessionId]
        {
            get
            {
                lock (_sessions)
                {
                    if (!_sessions.ContainsKey(sessionId))
                        return null;

                	_sessions[sessionId].Accessed = DateTime.Now;
                    if (sessionId.Length > 0)
                        ((MemorySession)_sessions[sessionId]).SetId(Guid.NewGuid().ToString());
                    return _sessions[sessionId];
                }
            }
        }

        /// <summary>
        /// Creates a new http session
        /// </summary>
        /// <returns></returns>
        public IHttpSession Create()
        {
            return Create(Guid.NewGuid().ToString());
        }


        /// <summary>
        /// Creates a new http session with a specific id
        /// </summary>
        /// <param name="id">Id used to identify the new cookie..</param>
        /// <returns>A <see cref="IHttpSession"/> object.</returns>
        /// <remarks>
        /// Id should be generated by the store implementation if it's null or <see cref="string.Empty"/>.
        /// </remarks>
        public IHttpSession Create(string id)
        {
            if (string.IsNullOrEmpty(id))
                id = Guid.NewGuid().ToString();

            lock (_unusedSessions)
            {
                if (_unusedSessions.Count > 0)
                {
                    MemorySession session = _unusedSessions.Dequeue() as MemorySession;
                    if (session != null)
                    {
                        session.SetId(id);
                        return session;
                    }
                }
            }

            return new MemorySession(id);
        }

        /// <summary>
        /// Load an existing session.
        /// </summary>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public IHttpSession Load(string sessionId)
        {
            if (_sessions.ContainsKey(sessionId))
                return _sessions[sessionId];
            
            return null;
        }

        /// <summary>
        /// Save an updated session to the store.
        /// </summary>
        /// <param name="session"></param>
        public void Save(IHttpSession session)
        {
            lock (_sessions)
            {
                if (_sessions.ContainsKey(session.Id))
                    _sessions[session.Id] = session;
                else
                    _sessions.Add(session.Id, session);
            }
        }

        /// <summary>
        /// We use the flyweight pattern which reuses small objects
        /// instead of creating new each time.
        /// </summary>
        /// <param name="session">EmptyLanguageNode (unused) session that should be reused next time Create is called.</param>
        public void AddUnused(IHttpSession session)
        {
            lock (_unusedSessions)
                _unusedSessions.Enqueue(session);
        }

        /// <summary>
        /// Remove expired sessions
        /// </summary>
        public void Cleanup()
        {
            lock (_sessions)
            {
                foreach (KeyValuePair<string, IHttpSession> pair in _sessions)
                {
                    // don't reuse used sessions since they may be in use when we remove them from the list.
                    TimeSpan liveTime = DateTime.Now.Subtract(pair.Value.Accessed);
                    if (liveTime.TotalMinutes > _expireTime)
                    {
						pair.Value.Clear(true);
                        _sessions.Remove(pair.Key);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Remove a session
        /// </summary>
        /// <param name="sessionId">id of the session.</param>
        public void Remove(string sessionId)
        {
            IHttpSession session;
            lock (_sessions)
            {
                if (!_sessions.ContainsKey(sessionId))
                    return;

                session = _sessions[sessionId];
                _sessions.Remove(sessionId);
            }

            session.Clear();
            lock (_unusedSessions)
                _unusedSessions.Enqueue(session);
        }

        /// <summary>
        /// Number of minutes before a session expires.
        /// Default is 20 minutes.
        /// </summary>
        public int ExpireTime
        {
            get { return _expireTime; }
            set { _expireTime = value; }
        }

        #endregion


    }
}